---
title: Keyhac
description: Keyhac ã‚’ä½¿ã£ã¦ã‚­ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚„ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰æ‹¡å¼µã‚’è¡Œã†æ–¹æ³•ã‚’è§£èª¬ã—ã¾ã™
keywords:
  - Keyhac
pagination_next: null
pagination_prev: null
image: https://og-image-mebiusbox.vercel.app/api/og?title=Keyhac&subtitle=Keyhac%20%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%82%AD%E3%83%BC%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%9E%E3%82%A4%E3%82%BA%E3%82%84%E3%82%AF%E3%83%AA%E3%83%83%E3%83%97%E3%83%9C%E3%83%BC%E3%83%89%E6%8B%A1%E5%BC%B5%E3%82%92%E8%A1%8C%E3%81%86%E6%96%B9%E6%B3%95%E3%82%92%E8%A7%A3%E8%AA%AC%E3%81%97%E3%81%BE%E3%81%99&date=2023%2F01%2F01
last_update:
  date: 2023-01-20
  author: mebiusbox
---

import Bookmark from '@site/src/components/Markdown/WebBookmark.tsx'

## Keyhac ã¨ã¯

Keyhac ã¨ã¯ã€Python ã‚’ä½¿ã£ã¦ã‚­ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒè¡Œãˆã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ï¼

https://sites.google.com/site/craftware/keyhac-ja

å®šå‹æ–‡å…¥åŠ›ã‚’ã‚¹ãƒ‹ãƒšãƒƒãƒˆã®ã‚ˆã†ã«å…¥åŠ›ã§ãã‚‹ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦ã€ [aText](https://www.trankynam.com/atext/) ã‚’ä½¿ã£ã¦ã„ã¾ã™ï¼ç„¡æ–™ã§ã‚‚å˜ç´”ãªå®šå‹æ–‡ã¯å…¥åŠ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ãƒ•ãƒ«æ©Ÿèƒ½ã‚’ä½¿ã†ãŸã‚ã«ã¯Proãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã—ãªã‘ã‚Œã°ãªã‚‰ãšã€æœ‰æ–™ã§ã™ï¼ãã‚“ãªã«é »ç¹ã«åˆ©ç”¨ã™ã‚‹ã‚ã‘ã§ã‚‚ãªã„ã§ã™ã—ã€ã¨ã‚Šã‚ãˆãšä»–ã®æ–¹æ³•ã§ã§ããªã„ã‹ã¨æ¢ã—ã¦ã„ãŸã¨ã“ã‚ã€Keyhacã«ãŸã©ã‚Šç€ãã¾ã—ãŸï¼

Keyhac ã®ã„ã„ã¨ã“ã‚ã¯ Python ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ã¨ã“ã‚ã«ã‚ã‚Šã¾ã™ï¼ä»¥å‰ã¯ [Charu3](http://keijiweb.com/software.html) ã‚’ä½¿ã£ã¦ã„ã¾ã—ãŸï¼ãƒã‚¯ãƒ­ã¯ç”¨æ„ã•ã‚Œã¦ã„ãŸã‚Šãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚‚ã‚ã‚‹ã®ã§ã€ã‚ã‚‹ç¨‹åº¦ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒã§ãã‚‹ã®ã§ã™ãŒã€ã‚„ã¯ã‚Šé™ç•ŒãŒã‚ã‚Šã¾ã™ï¼Python ãŒä½¿ãˆã‚‹ãªã‚‰ã€ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ä»¥å¤–ã®ã“ã¨ã‚‚ã„ã‚ã„ã‚ã§ãã‚‹ã®ã§æ±ç”¨æ€§ã¯é«˜ã„ã§ã™ï¼


## Keyhacã®è¨­å®š

Keyhacã®è¨­å®šæ–¹æ³•ã‚’è§£èª¬ã—ã¾ã™ï¼ç’°å¢ƒã¯ Windows ã§ã™ï¼
ã¾ãšã€Keyhacã‚’èµ·å‹•ã™ã‚‹ã¨ã‚·ã‚¹ãƒ†ãƒ ãƒˆãƒ¬ã‚¤ã«å¸¸é§ã—ã¾ã™ï¼ã‚·ã‚¹ãƒ†ãƒ ãƒˆãƒ¬ã‚¤ã‹ã‚‰Keyhacã‚¢ã‚¤ã‚³ãƒ³ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€`è¨­å®šã®ç·¨é›†`ã‚’é¸æŠã™ã‚‹ã¨ã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«(`config.py`)ãŒã‚¨ãƒ‡ã‚£ã‚¿ã§é–‹ã‹ã‚Œã¾ã™ï¼ã“ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†ã—ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ãƒˆãƒ¬ã‚¤ã‹ã‚‰å³ã‚¯ãƒªãƒƒã‚¯ã€`è¨­å®šã®ãƒªãƒ­ãƒ¼ãƒ‰`ã§åæ˜ ã•ã‚Œã¾ã™ï¼

### ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ç”»é¢

è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«å•é¡ŒãŒã‚ã£ãŸã‚Šã€å®Ÿè¡Œã—ãŸã¨ãã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ `print` ã™ã‚‹ã¨ã€ã“ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãªã„å ´åˆã€ã‚·ã‚¹ãƒ†ãƒ ãƒˆãƒ¬ã‚¤ã®Keyhacã‚¢ã‚¤ã‚³ãƒ³ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ï¼ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ç”»é¢ã‚’ã‚¯ãƒªã‚¢ã—ãŸã„å ´åˆã€ã‚·ã‚¹ãƒ†ãƒ ãƒˆãƒ¬ã‚¤ã‹ã‚‰Keyhacã‚¢ã‚¤ã‚³ãƒ³ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã¦`ç«¯æœ«ã®ã‚¯ãƒªã‚¢`ã‚’é¸æŠã—ã¾ã™ï¼ã¾ãŸã€`å†…éƒ¨ãƒ­ã‚°ã‚’ON`ã‚’é¸æŠã™ã‚‹ã¨ã€ãƒ­ã‚°æƒ…å ±ãŒã‚³ãƒ³ã‚½ãƒ¼ãƒ«ç”»é¢ã«å‡ºåŠ›ã•ã‚Œã¾ã™ï¼ç„¡åŠ¹ã«ã—ãŸã„ã¨ãã¯`å†…éƒ¨ãƒ­ã‚°ã‚’OFF`ã‚’é¸æŠã—ã¾ã™ï¼


### configureé–¢æ•°

Keyhacã‚’èµ·å‹•ã™ã‚‹ã¨ã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«(`config.py`)ã«ã‚ã‚‹`configure`é–¢æ•°ãŒå‘¼ã°ã‚Œã¾ã™ï¼ã“ã“ã«å‡¦ç†ã‚’è¨˜è¿°ã—ã¦ãã¾ã™ï¼


### ã‚¨ãƒ‡ã‚£ã‚¿ã®è¨­å®š

è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ç·¨é›†ã«ä½¿ã†ã‚¨ãƒ‡ã‚£ã‚¿ã‚’è¨­å®šã—ã¾ã™ï¼Visual Studio Codeã¯é–‹ãå ´åˆã¯æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ï¼

```py
keymap.editor = "code"
```


### ãƒ•ã‚©ãƒ³ãƒˆã®è¨­å®š

ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãªã©ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ•ã‚©ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¾ã™ï¼å¥½ããªãƒ•ã‚©ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¦ãã ã•ã„ï¼ãƒ•ã‚©ãƒ³ãƒˆã‚’æŒ‡å®šã™ã‚‹ã¨ã€èµ·å‹•ã«å°‘ã—æ™‚é–“ãŒã‹ã‹ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

```py
keymap.setFont("Iosevka", 16)
```

### ãƒ†ãƒ¼ãƒã®è¨­å®š

æ¨™æº–ã§ã¯ `white` ã¨ `black` ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ï¼

```py
keymap.setTheme("black")
```


### ã‚­ãƒ¼ã®å†ç™»éŒ²

Keyhacã§ã¯ã‚­ãƒ¼ã‚’åˆ¥ã®ã‚­ãƒ¼ã«å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ãã‚Œã«ã¯`keymap.replaceKey`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã„ã¾ã™ï¼ç§ã®å ´åˆã€`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`å¤‰æ›ã‚­ãƒ¼`ã‚’é©å½“ãªå ´æ‰€ã«å†å‰²ã‚Šå½“ã¦ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¿®é£¾ã‚­ãƒ¼ã¨ã—ã¦ãã‚Œã‚‰ã‚’ç™»éŒ²ã—ã¾ã™ï¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¿®é£¾ã‚­ãƒ¼ã®ç™»éŒ²ã¯ `keymap.defineModifier`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã„ã¾ã™ï¼

```py
# Key replacement
keymap.replaceKey("(29)", 235)  # ç„¡å¤‰æ›
keymap.replaceKey("(28)", 236)  # å¤‰æ›

# User modifier key definition
keymap.defineModifier(235, "User0")
keymap.defineModifier(236, "User1")
```


### ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¼ãƒãƒƒãƒ—

Keyhacã§ã¯ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã”ã¨ã«ã‚­ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã—ã€ã™ã¹ã¦ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«å¯¾ã—ã¦ã‚­ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ï¼å¾Œè€…ã®å ´åˆã€`keymap.defineWindowKeymap`ãƒ¡ã‚½ãƒƒãƒ‰ã§å–å¾—ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§è¨­å®šã—ã¾ã™ï¼

```py
# Global keymap which affects any windows
keymap_global = keymap.defineWindowKeymap()
```

ä¾‹ãˆã°ã€`Shift`ã‚­ãƒ¼ã¨`Z`ã‚­ãƒ¼ã‚’åŒæ™‚ã«æŠ¼ã—ãŸã¨ãã®å‡¦ç†ã‚’è¨­å®šã—ãŸã„å ´åˆã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

```py
keymap_global["S-Z"] = closure
```

ã‚­ãƒ¼ã«å¯¾å¿œã—ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’æŒ‡å®šã—ã¾ã™ï¼Keyhacã¯ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸã¨ãã«å¯¾å¿œã—ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å‘¼ã³å‡ºã—ã¾ã™ï¼

æŒ‡å®šã§ãã‚‹ã‚­ãƒ¼ã‚„ãƒ¢ãƒ‡ã‚£ãƒ•ã‚¡ã‚¤ã‚¢ã«ã¤ã„ã¦ã¯[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://crftwr.github.io/keyhac/mac/doc/ja/)ã‚’å‚ç…§ã—ã¦ãã ã•ã„ï¼


### åˆæœŸã®è¨­å®š

Keyhacã§ã¯æ¨™æº–ã§ã„ãã¤ã‹è¨­å®šã•ã‚Œã¦ã„ã¾ã™ï¼ã¾ãšã¯å…¨éƒ¨æ¶ˆã™ã‹ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ãŠãã¾ã—ã‚‡ã†ï¼


### Keyhacãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

`pyauto`ã¨`keyhac`ã¯Keyhacã«ç”¨æ„ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ï¼`pyauto`ã¯ä½ãƒ¬ãƒ™ãƒ«OSæ©Ÿèƒ½ã§ã€`keyhac`ã¯ãã‚Œä»¥å¤–ã®ã‚‚ã®ã§ã™ï¼ä¾‹ãˆã°ã€ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚’æ“ä½œã™ã‚‹å ´åˆã€`keyhac` ã® `setClipboardText`, `getClipboardText` ã‚’ä½¿ã„ã¾ã™ï¼

```py
from keyhac import setClipboardText, getClipboardText
```

é¢å€’ãªã‚‰ã€ä¸€æ‹¬ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ï¼

```py
from keyhac import *
```

ã“ã‚Œã‚‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã€è©³ã—ãã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ï¼

Keyhacã‚’ä½¿ã£ã¦ emacs ãƒ©ã‚¤ã‚¯ãªã‚­ãƒ¼æ“ä½œã‚’å®Ÿç¾ã—ã¦ã„ã‚‹æ–¹ãŒã„ã¾ã™ï¼è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚‚å‚è€ƒã«ãªã‚‹ã¨æ€ã„ã¾ã™ï¼

https://github.com/smzht/fakeymacs


## å®Ÿè£…ã—ãŸæ©Ÿèƒ½ã®ç´¹ä»‹

ãã‚Œã§ã¯ã€æ¬¡ã‹ã‚‰å…·ä½“çš„ãªè¨­å®šã‚’ã—ã¦ã„ãã¾ã™ï¼ã¨ã„ã£ã¦ã‚‚ã€ã‚ã¾ã‚Šä½¿ã„ã“ãªã—ã¦ã„ã‚‹è¨³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã®ã§æ‚ªã—ã‹ã‚‰ãšï¼
ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã¯ã€ãã‚Œãã‚Œåˆå‡ºã—ãŸå ´æ‰€ã«æ˜è¨˜ã—ã¦ã„ã¾ã™ï¼


### ã‚«ãƒ¼ã‚½ãƒ«ã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸­å¤®ã«ç§»å‹•ã™ã‚‹

`Shift`ã‚­ãƒ¼ã¨`å³Ctrl`ã‚­ãƒ¼ã‚’æŠ¼ã—ãŸã¨ãã«å®Ÿè¡Œã—ã¾ã™ï¼

```py
def set_cursor_pos(x, y):
    keymap.beginInput()
    keymap.input_seq.append(pyauto.MouseMove(x, y))
    keymap.endInput()

def cursor_to_center():
    wnd = keymap.getTopLevelWindow()
    wnd_left, wnd_top, wnd_right, wnd_bottom = wnd.getRect()
    to_x = int((wnd_left + wnd_right) / 2)
    to_y = int((wnd_bottom + wnd_top) / 2)
    set_cursor_pos(to_x, to_y)

keymap_global["S-RCtrl"] = cursor_to_center
```


### ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸­å¤®ã«ç§»å‹•ã™ã‚‹

å·¦å³ã®`Ctrl`ã‚­ãƒ¼ã‚’æŠ¼ã—ãŸã¨ãã«å®Ÿè¡Œã—ã¾ã™ï¼

```py
def delay(sec=0.05):
    time.sleep(sec)

def get_monitor_areas():
    monitors = pyauto.Window.getMonitorInfo()
    main_monitor_first = sorted(monitors, key=lambda x: x[2], reverse=True)
    non_taskbar_areas = list(map(lambda x: x[1], main_monitor_first))
    return non_taskbar_areas
    
def set_window_rect(rect):
    wnd = keymap.getTopLevelWindow()
    if list(wnd.getRect()) == rect:
        wnd.maximize()
    else:
        if wnd.isMaximized():
            wnd.restore()
            delay()
        wnd.setRect(rect)

def window_to_center():
    wnd = keymap.getTopLevelWindow()
    if wnd.isMaximized():
        return None
    wnd_left, wnd_top, wnd_right, wnd_bottom = wnd.getRect()
    width = wnd_right - wnd_left
    height = wnd_bottom - wnd_top
    mntr_left, mntr_top, mntr_right, mntr_bottom = get_monitor_areas()[0]
    center_h = (mntr_right - mntr_left) / 2
    center_v = (mntr_bottom - mntr_top) / 2
    lx = int(center_h - width / 2)
    ly = int(center_v - height / 2)
    to_rect = (lx, ly, lx + width, ly + height)
    set_window_rect(to_rect)

keymap_global["C-RCtrl"] = window_to_center
```

ã‚‚ã—ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æœ€å¤§åŒ–ã—ã¦ã„ãŸå ´åˆã€å…ˆã«é€šå¸¸ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«æˆ»ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ãã®å ´åˆã€æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ï¼

```py
def window_to_center_force():
    wnd = keymap.getTopLevelWindow()
    if wnd.isMaximized():
        wnd.restore()
        delay()
    window_to_center()
```


### ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ç§»å‹•ã™ã‚‹

`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`å³Ctrl`ã‚­ãƒ¼ã‚’æŠ¼ã—ãŸã¨ãã«å®Ÿè¡Œã—ã¾ã™ï¼

```py
def window_to_cursor():
    wnd = keymap.getTopLevelWindow()
    if wnd.isMaximized():
        return None
    wnd_left, wnd_top, wnd_right, wnd_bottom = wnd.getRect()
    width = wnd_right - wnd_left
    height = wnd_bottom - wnd_top
    x, y = pyauto.Input.getCursorPos()
    to_rect = (x, y, x + width, y + height)
    set_window_rect(to_rect)

keymap_global["U0-RCtrl"] = window_to_cursor
```


### ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹

`Alt+Tab`ã‚„`Win+Tab`ã®ã‚ˆã†ãªæ©Ÿèƒ½ã§ã™ï¼Keyhacã§ã¯ãƒªã‚¹ãƒˆã‚’è¡¨ç¤ºã™ã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ©Ÿèƒ½ãŒã‚ã‚Šã¾ã™ã®ã§ã€ãã¡ã‚‰ã‚’ä½¿ã„ã¾ã™ï¼ä»Šå›ã¯ã€`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`ã‚¹ãƒšãƒ¼ã‚¹`ã‚­ãƒ¼ã‚’æŠ¼ã—ãŸã¨ãã«å®Ÿè¡Œã—ã¾ã™ï¼

```py {47} showLineNumbers
# import re
# from keyhac import cblister_FixedPhrase
debug_mode = False # ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ã‚’æœ‰åŠ¹ã«ã™ã‚‹å ´åˆã¯ True ã«ã™ã‚‹
def dbg(text):
    if debug_mode:
        print("dbg: " + text)

def truncate(string, length, ellipsis="..."):
    return string[:length] + (ellipsis if string[length:] else "")

def truncate_cjk(string, length, ellipsis="..."):
    # http://www.unicode.org/reports/tr11/
    count = 0
    text = ""
    for c in string:
        if unicodedata.east_asian_width(c) in "FWA":
            count += 2
        else:
            count += 1

        if count > length:
            text += ellipsis
            break
        text += c
    return text
    
def switch_windows():
    dbg(">>>>> switch_windows <<<<<")

    def popWindowList():
        # If the list window is already opened, just close it
        if keymap.isListWindowOpened():
            keymap.cancelListWindow()
            return

        def getWindowList(wnd, arg):
            if not wnd.isVisible():
                return True
            # if not wnd.getOwner():
            #     return True
            if wnd.getText() == "":
                return True
            dbg(wnd.getProcessName())
            dbg("  " + wnd.getClassName())
            dbg("    " + wnd.getText())
            if re.match(
                r"(keyhac|SystemSettings|ApplicationFrameHost|TextInputHost|explorer|onenoteim)\.exe",
                wnd.getProcessName(),
            ):
                dbg("(pass)")
                return True
            # if re.match(r"chrome", wnd.getClassName()):
            #     window_list.append(wnd)
            window_list.append(wnd)
            return True

        window_list = []
        Window.enum(getWindowList, None)

        popup_list = [
            ("{:>20s} :: {}".format(truncate(i.getProcessName()[:-4], 17), truncate_cjk(i.getText(), 45)), i)
            for i in sorted(window_list, key=lambda x: x.getProcessName())
        ]

        if mysetting.debug:
            for i in popup_list:
                dbg(i[0])

        listers = [("Windows", cblister_FixedPhrase(popup_list))]
        item, mod = keymap.popListWindow(listers)
        if item:
            item[1].setForeground()

    # Because the blocking procedure cannot be executed in the key-hook,
    # delayed-execute the procedure by delayedCall().
    keymap.delayedCall(popWindowList, 0)

keymap_global["U0-Space"] = switch_windows
```

å®Ÿè¡Œçµæœã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

![](/img/post/keyhac-230127014527.png)

æ­£è¦è¡¨ç¾(Line:47)ã‚’ä½¿ã£ã¦è¡¨ç¤ºã•ã‚Œã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’åˆ¶é™ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ï¼

:::info
ã¡ãªã¿ã«ã€ä»¥å‰ã¯[Tascher](http://frostmoon.sakura.ne.jp/Tascher/)ã¨ã„ã†ã®ã‚’ä½¿ã£ã¦ã„ãŸã®ã§ã™ãŒã€Keyhacã«ç½®ãæ›ãˆã¾ã—ãŸï¼
:::

:::info
Keyhacã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ©Ÿèƒ½ã¯ã€å®Ÿã¯è¤‡æ•°ã®ãƒªã‚¹ãƒˆã‚’å†…éƒ¨ã§æŒã¤ã“ã¨ãŒã§ãã¾ã™ï¼ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã«ã‚ã‚‹ã‚ˆã†ã«ã€`listers`ã«é…åˆ—ã‚’è¨­å®šã—ã¦ã„ã¾ã™ï¼

```py
listers = [("Windows", cblister_FixedPhrase(popup_list))]
```

è¤‡æ•°æŒ‡å®šã—ãŸå ´åˆã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®å·¦å³ã‚­ãƒ¼ã§åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼
:::


### ãƒ–ãƒ©ã‚¦ã‚¶(Chrome)ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹

Chromeã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æ¬¡ã€…ã«åˆ‡ã‚Šæ›¿ãˆã‚‹æ©Ÿèƒ½ã§ã™ï¼`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`F7`ã‚­ãƒ¼ã«å‰²ã‚Šå½“ã¦ã¦ã„ã¾ã™ï¼

```py
# import time
# from keyhac import Window
chrome_history = []
def next_chrome_window():
    dbg(">>>>> next_chrome_window <<<<<")

    def getWindowList(wnd, arg):
        if not wnd.isVisible():
            return True
        # if not wnd.getOwner():
        #     return True
        if wnd.getText() == "":
            return True
        # dbg(wnd.getProcessName())
        if re.match(r"chrome", wnd.getProcessName()):
            window_list.append(wnd)
        # if re.match(r"chrome", wnd.getClassName()):
        #     window_list.append(wnd)
        # window_list.append(wnd)
        return True

    now = time.time_ns() / 1_000_000  # ms
    history = sorted(chrome_history, key=lambda x: x[1], reverse=True)
    if len(history) > 0:
        dbg("{}".format(now - history[0][1]))
        if now - history[0][1] > 5_000:  # 5s
            dbg("clear chrome history")
            chrome_history = []
            history = []

    if debug:
        for entry in history:
            dbg(f"{entry[0]}, {entry[1]}")

    next_window = (None, -1)
    window_list = []
    Window.enum(getWindowList, None)
    current_wnd_text = keymap.getTopLevelWindow().getText()
    dbg(f"[current] {current_wnd_text}")
    for wnd in window_list:
        text = wnd.getText()
        if current_wnd_text == text:
            continue
        idx = [i for i, e in enumerate(history) if e[0] == text]
        if len(idx) > 0:
            if next_window[1] < idx[0]:
                dbg(f"found in history: {text}({idx[0]})")
                next_window = (wnd, idx[0])
        else:
            dbg(f"not found in history: {text}")
            next_window = (wnd, len(history))
            break

    if next_window[0]:
        dbg("[next] " + next_window[0].getText())
        chrome_history.append((next_window[0].getText(), now))
        next_window[0].setForeground()
        
keymap_global["U0-F7"] = next_chrome_window
```


### ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹

`keymap.ShellExecuteCommand`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã„ã¾ã™ï¼

```py
keymap.ShellExecuteCommand(verb, file, param, directory, swmode);
```

ç§ã¯æ¬¡ã®ã‚ˆã†ãªãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’å®šç¾©ã—ã¦ä½¿ã£ã¦ã„ã¾ã™ï¼

```py
def shell(s, arg=None):
    return keymap.ShellExecuteCommand(None, s, arg, None)

def shell_mini(s, arg=None):
    return keymap.ShellExecuteCommand(None, s, arg, None, "minimized")
```

ä¾‹ãˆã°ã€Chromeã§ç‰¹å®šã®URLã‚’é–‹ããŸã„å ´åˆã¯æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ï¼

```py
keymap_global["U0-F9"] = shell(
    "C:\\Program Files\\Google\\Chrome\\Application\\Chrome.exe",
    "--new-window https://www.google.com/webhp?hl=ja",
)
```


### VSCodeã®é¸æŠç¯„å›²æ‹¡å¤§(x2)

Visual Studio Code ã§ `Shift+Alt+å³`ã‚­ãƒ¼ã¯é¸æŠç¯„å›²ã®æ‹¡å¤§ã«ãªã‚Šã¾ã™ï¼ã¡ã‚‡ã†ã©2å›å®Ÿè¡Œã™ã‚‹ã¨ã€ã„ã„æ„Ÿã˜ã«é¸æŠã§ãã‚‹ã“ã¨ãŒå¤šã„ãŸã‚é‡å®ã—ã¦ã„ã¾ã™ï¼ã—ã‹ã—ã€`Shift+Alt+å³`ã‚­ãƒ¼ã¯æŠ¼ã—ã¥ã‚‰ã„ã§ã™ï¼ãã“ã§ã€`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`å³`ã‚­ãƒ¼æŠ¼ã—ã§2å›åˆ†ã®`Shift+Alt+å³`ã‚­ãƒ¼ã‚’æŠ¼ã™ã‚ˆã†ã«ã—ã¾ã™ï¼

```py
def ikey(*keys):
    return keymap.InputKeyCommand(*keys)

keymap_global["U0-Right"] = ikey("S-A-Right", "S-A-Right")
```


### ãƒãƒ«ãƒã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚­ãƒ¼

Keyhacã§ã¯ãƒãƒ«ãƒã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚­ãƒ¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ï¼`keymap.defineMultiStrokeKeymap`ã§æœ€åˆã®ã‚­ãƒ¼ã‚’ç™»éŒ²ã—ã¾ã™ï¼ä¾‹ãˆã°ã€`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`D`ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã€æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æŒ‡å®šã—ã¦å…¥åŠ›ã—ãŸã„å ´åˆã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

```py
def send_keys(*keys):
    keymap.beginInput()
    for key in keys:
        keymap.setInput_FromString(str(key))
    keymap.endInput()
    keymap._fixFunnyModifierState()
    
def set_ime(mode):
    if keymap.getWindow().getImeStatus() != mode:
        send_keys("(243)")
        delay(0.01)

def input_date(fmt):
    def _input_data():
        d = datetime.datetime.today()
        date_str = d.strftime(fmt)
        set_ime(0)
        send_input(date_str, 0)

    return _input_data

keymap_global["U0-D"] = keymap.defineMultiStrokeKeymap("DATE: [1]YMD, [2]Y/M/D, [3]Y-M-D")
for key, args in {
    "1": ["%Y%m%d"],
    "2": ["%Y/%m/%d"],
    "3": ["%Y-%m-%d"],
}.items():
    keymap_global["U0-D"][key] = input_date(*args)
```

å®Ÿè¡Œã™ã‚‹ã¨ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ä¸‹ã« `DATE: [1]YMD, [2]Y/M/D, [3]Y-M-D` ãŒè¡¨ç¤ºã•ã‚Œã€æ¬¡ã®ã‚­ãƒ¼å…¥åŠ›å¾…ã¡ã«ãªã‚Šã¾ã™ï¼ã“ã“ã§ã¯ `1`ã€`2`ã€`3`ã‚­ãƒ¼ã®ã©ã‚Œã‹ã‚’æŠ¼ã™ã¨ã€ãã‚Œãã‚Œã®æ›¸å¼ã«å¯¾å¿œã—ãŸæ—¥ä»˜ãŒå…¥åŠ›ã•ã‚Œã¾ã™ï¼

ä»–ã«ã€æ‹¬å¼§ã®å…¥åŠ›æ”¯æ´ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼(`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`P`ã‚­ãƒ¼)

```py
def send_string(s):
    keymap.beginInput()
    keymap.setInput_Modifier(0)
    for c in s:
        keymap.input_seq.append(pyauto.Char(c))
    keymap.endInput()
    
def send_input(sequence, sleep=0.01):
    for elem in sequence:
        delay(sleep)
        try:
            send_keys(elem)
        except:
            send_string(elem)
            
def ime_input0(*sequence):
    def _ime_input0():
        set_ime(0)
        send_input(sequence)

    return _ime_input0

def ime_input1(*sequence):
    def _ime_input1():
        set_ime(1)
        send_input(sequence)

    return _ime_input1

keymap_global["U0-P"] = keymap.defineMultiStrokeKeymap("PARENTHES: [1]ã€Šã€‹ [2]ã€ˆã€‰ [3]ã€”ã€• [4]ã€ã€ [5]ã€ã€‘ [6]ï¼ˆï¼‰ [7]()")
for key, args in {
    "1": ["ã€Šã€‹", "Left"],
    "2": ["ã€ˆã€‰", "Left"],
    "3": ["ã€”ã€•", "Left"],
    "4": ["ã€ã€", "Left"],
    "5": ["ã€ã€‘", "Left"],
    "6": ["ï¼ˆï¼‰", "Left"],
    "7": ["()", "Left"],
}.items():
    keymap_global["U0-P"][key] = ime_input1(*args)
```


### æ—¥æœ¬èªå…¥åŠ›æ™‚ã«åŠè§’ã®æ‹¬å¼§ã‚’å…¥ã‚Œã‚‹

é€šå¸¸ã¯å…¨è§’ã®æ‹¬å¼§(`ï¼ˆï¼‰`)ã§ã™ãŒã€åŠè§’ã‚’å…¥ã‚Œã‚‹ã‚ˆã†ã«ã§ãã¾ã™ï¼

```py
def ime_context(func):
    def _ime_context():
        mode = keymap.getWindow().getImeStatus()
        func()
        set_ime(mode)

    return _ime_context

keymap_global["U0-8"] = ime_context(ime_input0("S-8"))
keymap_global["U0-9"] = ime_context(ime_input0("S-9"))
```

`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`8`ã‚­ãƒ¼ã§`(`ãŒã€`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`9`ã‚­ãƒ¼ã§`)`ãŒæ—¥æœ¬èªå…¥åŠ›æ™‚ã«å…¥ã‚Œã‚‰ã‚Œã¾ã™ï¼

åŒã˜ã‚„ã‚Šæ–¹ã§ã€`ï¼`ã‚’`/`ã€`ã€Œã€`ã‚’`[]`ã¨å…¥åŠ›ã§ãã¾ã™ï¼

```py
keymap_global["U0-OpenBracket"] = ime_context(ime_input0("OpenBracket"))
keymap_global["U0-CloseBracket"] = ime_context(ime_input0("CloseBracket"))
keymap_global["U0-Slash"] = ime_context(ime_input0("Slash"))
```


### ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ã‚µãƒ¼ãƒ

Keyhacã¯ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã—ãŸã¨ãã«ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ã‚µãƒ¼ãƒã‚’ä½¿ãˆã‚‹ã®ã§ã™ãŒã€æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰(`f`ã‚­ãƒ¼)ã«å…¥ã‚‰ãªã„ã¨ä½¿ãˆãªã„ã®ã§ä¸ä¾¿ã§ã™ï¼ãã“ã§ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã—ãŸã¨ãã«è‡ªå‹•ã§æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹ã‚ˆã†ã«ã—ãŸã„ã®ã§ã™ãŒã§ãã¾ã›ã‚“ï¼ã¾ãŸã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¯ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã®ä¸­å¤®ã«è¡¨ç¤ºã—ã¦ã»ã—ã„ã®ã§ã™ãŒã€æ¨™æº–ã§ã¯ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã®åŸç‚¹(ã¤ã¾ã‚Šå·¦ä¸Š)ã«è¡¨ç¤ºã•ã‚Œã¾ã™ï¼ã“ã‚ŒãŒã¨ã¦ã‚‚ä¸æº€ã ã£ãŸã®ã§ã™ãŒã€ãªã‚“ã¨ã‹å¦¥å”ã§ãã‚‹ãƒ¬ãƒ™ãƒ«ã«ã§ãã¾ã—ãŸï¼ãã‚Œã¯ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã™ã‚‹ã‚­ãƒ¼ã‚’2å›é€£ç¶šã§æŠ¼ã™ã“ã¨ã§ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä¸­å¤®ã«ç§»å‹•ã—ã¦ã€æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ï¼æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ï¼

```py
def lw_search():
    ikey("F")()
    lw_search_mode = True

def lw_exit():
    if lw_search_mode:
        ikey("Esc", "Esc")()
    else:
        ikey("Esc")()

def is_list_window(window):
    if window.getClassName() == "KeyhacWindowClass" and window.getText() != "Keyhac":
        lw_search_mode = False
        return True
    else:
        return False

keymap_lw = keymap.defineWindowKeymap(check_func=is_list_window)
keymap_lw["U0-N"] = ikey("Down")
keymap_lw["U0-P"] = ikey("Up")
keymap_lw["U0-AtMark"] = lambda: [window_to_center(), lw_search()]
keymap_lw["U0-Space"] = lambda: [window_to_center(), lw_search()]
keymap_lw["U0-Semicolon"] = lambda: [window_to_center(), lw_search()]
keymap_lw["Enter"] = ikey("Enter", "Enter")
keymap_lw["Escape"] = lw_exit
```

`keymap_lw`ã¯KeyhacãŒè¡¨ç¤ºã™ã‚‹ãƒªã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«é©ç”¨ã•ã‚Œã‚‹ã‚­ãƒ¼ãƒãƒƒãƒ—ã§ã™ï¼ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã™ã‚‹ã‚­ãƒ¼ã« `lambda: [window_to_center(), lw_search()]` ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä¸­å¤®ã«è¡¨ç¤ºã—ã€æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€`Enter`ã‚­ãƒ¼ã‚’æŠ¼ã™ã¨ã€æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ãŒçµ‚äº†ã™ã‚‹ã ã‘ãªã®ã§ã€2å›`Enter`ã‚­ãƒ¼ã‚’æŠ¼ã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ï¼

ã¾ãŸã€`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`N`ã‚­ãƒ¼ã¾ãŸã¯`P`ã‚­ãƒ¼ã§ä¸Šä¸‹ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒç§»å‹•ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ï¼ä»–ã«`Escape`ã‚­ãƒ¼ã®å‡¦ç†ã‚’ã—ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚‚æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ã‹ã‚‰æŠœã‘ã‚‹ã ã‘ãªã®ã§ã€2å›æŠ¼ã—ãŸã“ã¨ã«ã—ã¦ã„ã¾ã™


### ã‚³ãƒãƒ³ãƒ‰ãƒ‘ãƒ¬ãƒƒãƒˆ

`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`@`ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã‚³ãƒãƒ³ãƒ‰ãƒ‘ãƒ¬ãƒƒãƒˆã‚’è¡¨ç¤ºã—ã¾ã™ï¼å„ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè£…ã¯ã€ã“ã®ãƒšãƒ¼ã‚¸ã®æœ€å¾Œã«ã‚ã‚Šã¾ã™ï¼

```py
def command_PopCommandList():
    # If the list window is already opened, just close it
    if keymap.isListWindowOpened():
        keymap.cancelListWindow()
        return

    def popCommandList():
        commands = [
            ("  :splitlines_with_period", splitlines_with_period),
            ("  :remove_bullet", remove_bullet),
            ("  :remove_breaklines", remove_breaklines),
            ("  :remove_breaklines_with_trim", remove_breaklines_with_trim),
            ("  :replace_zenkaku_punctuation", replace_zenkaku_punctuation),
            ("1 :stanza_runner", stanza_runner),
            ("  :stanza_displacy", stanza_displacy),
            ("  :number_to_half_width", number_to_half_width),
            ("  :number_to_full_width", number_to_full_width),
            ("  :url_encode", url_encode),
            ("  :url_decode", url_decode),
            ("  :uuid", gen_uuid),
            ("  :uuid8", gen_uuid8),
            ("  :config(edit)", keymap.command_EditConfig),
            ("  :config(reload)", keymap.command_ReloadConfig),
            ("  :convert_google_drive_image_url", convert_google_drive_image_url),
            ("  ^since:today", itext("since:" + date_and_time("%Y-%m-%d", 0))),
            ("  ^since:yesterday", itext("since:" + date_and_time("%Y-%m-%d", -1))),
        ]

        listers = [("Commmand", cblister_FixedPhrase(commands))]

        item, mod = keymap.popListWindow(listers)

        if item:
            item[1]()

    # Because the blocking procedure cannot be executed in the key-hook,
    # delayed-execute the procedure by delayedCall().
    keymap.delayedCall(popCommandList, 0)

keymap_global["U0-AtMark"] = command_PopCommandList
```

å®Ÿè¡Œã™ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

![](/img/post/keyhac-230127023247.png)

å·¥å¤«ã—ã¦ã„ã‚‹ã¨ã“ã‚ã¯ `1 :stanza_runner` ã¨ã„ã†éƒ¨åˆ†ãŒã‚ã‚Šã¾ã™ï¼ã“ã‚Œã¯ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã—ãŸã‚‰`1`ã‚­ãƒ¼ã‚’æŠ¼ã™ã¨ãã®ã‚³ãƒãƒ³ãƒ‰ãŒé¸æŠçŠ¶æ…‹ã«ãªã‚Šã¾ã™ï¼ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã§ã™ã­ï¼

ã‚ã¨ã€ã‚³ãƒãƒ³ãƒ‰åã§ã¯ `^xxx` ã§å®šå‹æ–‡ã‚’ã€`:xxx`ã¯ãã‚Œä»¥å¤–ã«åˆ†é¡ã—ã¦ã„ã¾ã™ï¼

ä»¥ä¸‹ã®2ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã‚Œãã‚Œã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ç·¨é›†ã€å†èª­ã¿è¾¼ã¿ã‚’ã—ã¾ã™ï¼ç‰¹ã«è¨­å®šã‚’ç·¨é›†ã—ã¦å†èª­ã¿è¾¼ã¿ã¯é »ç¹ã«åˆ©ç”¨ã—ã¾ã™ï¼

- keymap.command_EditConfig
- keymap.command_ReloadConfig


### ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´

Keyhacã§ã¯ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã®æ©Ÿèƒ½ãŒæ¨™æº–ã§å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ï¼ãã®ãŸã‚ã«`ãƒ•ãƒƒã‚¯`ã‚’æœ‰åŠ¹ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ç¢ºèªã™ã‚‹ã«ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ãƒˆãƒ¬ã‚¤ã‹ã‚‰Keyhacã‚¢ã‚¤ã‚³ãƒ³ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã¦ç¢ºèªã§ãã¾ã™ï¼ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã®è¨­å®šã¯æ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ï¼

```py
# Enable clipboard monitoring hook (Default:Enabled)
keymap.clipboard_history.enableHook(True)

# Maximum number of clipboard history (Default:1000)
keymap.clipboard_history.maxnum = 10

# Total maximum size of clipboard history (Default:10MB)
keymap.clipboard_history.quota = 10 * 1024 * 1024
```

åˆæœŸè¨­å®šã®çŠ¶æ…‹ã ã¨ã€ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã¯ `Ctrl+Shift+Z`ã‚­ãƒ¼ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã¾ã™ï¼

```py
# Open the clipboard history list
keymap_global["C-S-Z"] = keymap.command_ClipboardList
# Move the most recent history to tail
keymap_global["C-S-X"] = keymap.command_ClipboardRotate
# Remove the most recent history
keymap_global["C-S-A-X"] = keymap.command_ClipboardRemove
# Mark for quote pasting
keymap.quote_mark = "> "
```

ãŸã ã€æ¨™æº–ã®è¨­å®šã§ã¯ã¨ã¦ã‚‚ä½¿ã„ã¥ã‚‰ã„ã¨æ„Ÿã˜ã¾ã—ãŸï¼ç’°å¢ƒã«ã‚ˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã‹ã‚‰ã®ç›´æ¥è²¼ã‚Šä»˜ã‘ãŒ(`Shift+Enter`ã‚­ãƒ¼)ãŒåŠ¹ã‹ãšã«å›°ã‚Šã¾ã—ãŸï¼ã¾ãŸã€æ•°å­—ã«ã‚ˆã‚‹ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚‚ä½¿ã„ãŸã‹ã£ãŸã®ã§ã€è‡ªå‰ã§å®Ÿè£…ã—ã¾ã™ï¼å¹¸ã„ãªã“ã¨ã«ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´è‡ªä½“ã¯å–å¾—ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã®ã§ã€ã‚ã¨ã¯ã‚³ãƒãƒ³ãƒ‰ãƒ‘ãƒ¬ãƒƒãƒˆã¨åŒã˜ã‚„ã‚Šæ–¹ã§å®Ÿè£…ã—ã¾ã™ï¼ã¤ã„ã§ã«ã€å®šå‹æ–‡æ©Ÿèƒ½ã‚‚è¿½åŠ ã—ã¾ã™ï¼

```py
phrase = []
phrase.append(("name", "snippet code here"))

def paste_string(s):
    setClipboardText(s)
    send_keys("C-V")
    
def command_PopHistoryList():
    # If the list window is already opened, just close it
    if keymap.isListWindowOpened():
        keymap.cancelListWindow()
        return

    def popHistoryList():
        def direct_paste(s):
            def _direct_paste():
                paste_string(s)

            return _direct_paste

        histories = []
        items = keymap.clipboard_history.getListItems()
        for i, item in enumerate(items):
            histories.append(("{}: {}".format((i + 1) % 10, item[0]), direct_paste(item[1])))
        for i, item in enumerate(phrase):
            histories.append(("{}: {}".format(chr(ord("a") + i), item[0]), direct_paste(item[1])))

        listers = [("Clipboard", cblister_FixedPhrase(histories))]
        item, mod = keymap.popListWindow(listers)
        if item:
            item[1]()

    # Because the blocking procedure cannot be executed in the key-hook,
    # delayed-execute the procedure by delayedCall().
    keymap.delayedCall(popHistoryList, 0)

keymap_global["U0-Semicolon"] = command_PopHistoryList
```

ç§ã¯`ç„¡å¤‰æ›`ã‚­ãƒ¼ã¨`;`ã‚­ãƒ¼ã§å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«è¨­å®šã—ã¦ã„ã¾ã™ï¼æ¬¡ã®ã‚ˆã†ã«è¡¨ç¤ºã•ã‚Œã¾ã™ï¼

![](/img/post/keyhac-230127024747.png)

`phrase`å¤‰æ•°ã§å®šå‹æ–‡ã‚’è¿½åŠ ã§ãã¾ã™ï¼ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å±¥æ­´ã¯æ•°å­—ã§ã€å®šå‹æ–‡ã¯ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆãŒã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã«ãªã‚Šã¾ã™ï¼


## è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«

æœ€å¾Œã«ç§ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æŠœç²‹ã§ã™ï¼

```py title=config.py
import os
import datetime
import time
import re
import unicodedata
import urllib
import uuid
import pyauto
from keyhac import setClipboardText, getClipboardText, cblister_FixedPhrase, JobItem, JobQueue, Window

def configure(keymap):
    class MySetting:
        def __init__(self):
            self.chrome_history = []
            self.debug = False
            self.lw_search_mode = False
            self.phrase = []

    mysetting = MySetting()

    # Phrase
    # mysetting.phrase.append(("name", "snippet code here"))

    # User Define Functions

    def dbg(text):
        if mysetting.debug:
            print("dbg: " + text)

    def itext(text):
        return keymap.InputTextCommand(text)

    def ikey(*keys):
        return keymap.InputKeyCommand(*keys)

    def shell(s, arg=None):
        return keymap.ShellExecuteCommand(None, s, arg, None)

    def shell_mini(s, arg=None):
        return keymap.ShellExecuteCommand(None, s, arg, None, "minimized")

    def delay(sec=0.05):
        time.sleep(sec)

    def get_current_clipboard():
        s = getClipboardText() or ""
        return s

    def send_keys(*keys):
        keymap.beginInput()
        for key in keys:
            keymap.setInput_FromString(str(key))
        keymap.endInput()
        keymap._fixFunnyModifierState()

    def send_string(s):
        keymap.beginInput()
        keymap.setInput_Modifier(0)
        for c in s:
            keymap.input_seq.append(pyauto.Char(c))
        keymap.endInput()

    def send_input(sequence, sleep=0.01):
        for elem in sequence:
            delay(sleep)
            try:
                send_keys(elem)
            except:
                send_string(elem)

    def set_ime(mode):
        if keymap.getWindow().getImeStatus() != mode:
            send_keys("(243)")
            delay(0.01)

    def copy_string(sec=0.01):
        setClipboardText("")
        send_keys("C-Insert")
        delay(sec)
        return get_current_clipboard()

    def paste_string(s):
        setClipboardText(s)
        send_keys("C-V")

    def ime_input0(*sequence):
        def _ime_input0():
            set_ime(0)
            send_input(sequence)

        return _ime_input0

    def ime_input1(*sequence):
        def _ime_input1():
            set_ime(1)
            send_input(sequence)

        return _ime_input1

    def ime_context(func):
        def _ime_context():
            mode = keymap.getWindow().getImeStatus()
            func()
            set_ime(mode)

        return _ime_context

    def set_cursor_pos(x, y):
        keymap.beginInput()
        keymap.input_seq.append(pyauto.MouseMove(x, y))
        keymap.endInput()

    def cursor_to_center():
        wnd = keymap.getTopLevelWindow()
        wnd_left, wnd_top, wnd_right, wnd_bottom = wnd.getRect()
        to_x = int((wnd_left + wnd_right) / 2)
        to_y = int((wnd_bottom + wnd_top) / 2)
        set_cursor_pos(to_x, to_y)

    def get_monitor_areas():
        monitors = pyauto.Window.getMonitorInfo()
        main_monitor_first = sorted(monitors, key=lambda x: x[2], reverse=True)
        non_taskbar_areas = list(map(lambda x: x[1], main_monitor_first))
        return non_taskbar_areas

    def set_window_rect(rect):
        wnd = keymap.getTopLevelWindow()
        if list(wnd.getRect()) == rect:
            wnd.maximize()
        else:
            if wnd.isMaximized():
                wnd.restore()
                delay()
            wnd.setRect(rect)

    def window_to_center_force():
        wnd = keymap.getTopLevelWindow()
        if wnd.isMaximized():
            wnd.restore()
            delay()
        window_to_center()

    def window_to_center():
        wnd = keymap.getTopLevelWindow()
        if wnd.isMaximized():
            return None
        wnd_left, wnd_top, wnd_right, wnd_bottom = wnd.getRect()
        width = wnd_right - wnd_left
        height = wnd_bottom - wnd_top
        mntr_left, mntr_top, mntr_right, mntr_bottom = get_monitor_areas()[0]
        center_h = (mntr_right - mntr_left) / 2
        center_v = (mntr_bottom - mntr_top) / 2
        lx = int(center_h - width / 2)
        ly = int(center_v - height / 2)
        to_rect = (lx, ly, lx + width, ly + height)
        set_window_rect(to_rect)

    def window_to_cursor():
        wnd = keymap.getTopLevelWindow()
        if wnd.isMaximized():
            return None
        wnd_left, wnd_top, wnd_right, wnd_bottom = wnd.getRect()
        width = wnd_right - wnd_left
        height = wnd_bottom - wnd_top
        x, y = pyauto.Input.getCursorPos()
        to_rect = (x, y, x + width, y + height)
        set_window_rect(to_rect)

    def find_window(pattern):
        dbg(">>>>> find_window <<<<<")

        def getWindowList(wnd, arg):
            if not wnd.isVisible():
                return True
            # if not wnd.getOwner():
            #     return True
            if wnd.getText() == "":
                return True
            dbg(wnd.getProcessName())
            dbg("  " + wnd.getClassName())
            dbg("    " + wnd.getText())
            if re.match(
                r"{0}".format(pattern),
                wnd.getProcessName(),
            ):
                dbg("(found)")
                window_list.append(wnd)
                return False
            # if re.match(r"chrome", wnd.getClassName()):m
            #     windom_list.append(wnd)
            return True

        window_list = []
        Window.enum(getWindowList, pattern)

        if len(window_list) > 0:
            return window_list[0]

        dbg("(not found.)")
        return None

    def foreground_window(wnd):
        dbg(">>>>> foreground_window <<<<<")
        if wnd.isMinimized():
            wnd.restore()
            delay()
        wnd.setForeground()

    full_width_chars = (
        "ï½ï½‚ï½ƒï½„ï½…ï½†ï½‡ï½ˆï½‰ï½Šï½‹ï½Œï½ï½ï½ï½ï½‘ï½’ï½“ï½”ï½•ï½–ï½—ï½˜ï½™ï½šï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ªï¼«ï¼¬ï¼­ï¼®ï¼¯ï¼°ï¼±ï¼²ï¼³ï¼´ï¼µï¼¶ï¼·ï¼¸ï¼¹ï¼ºï¼â€ï¼ƒï¼„ï¼…ï¼†â€™ï¼ˆï¼‰ï¼Šï¼‹ï¼Œâˆ’ï¼ï¼ï¼šï¼›ï¼œï¼ï¼ï¼Ÿï¼ ï¼»ï¿¥ï¼½ï¼¾ï¼¿â€˜ï½›ï½œï½ï½ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™ã€€"
    )
    half_width_chars = (
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\]^_`{|}ï½0123456789 "
    )

    # Convert to half-with characters
    def to_half_width_clipboard_text():
        s = getClipboardText()
        s = s.translate(str.maketrans(full_width_chars, half_width_chars))
        return s

    # Convert to full-with characters
    def to_full_width_clipboard_text():
        s = getClipboardText()
        s = s.translate(str.maketrans(half_width_chars, full_width_chars))
        return s

    # Convert to half-with characters
    def number_to_half_width():
        s = getClipboardText()
        s = s.translate(str.maketrans("ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™", "0123456789"))
        paste_string(s)

    # Convert to full-with characters
    def number_to_full_width():
        s = getClipboardText()
        s = s.translate(str.maketrans("0123456789", "ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™"))
        paste_string(s)

    # Convert to emoji numbers
    def to_emoji():
        # emoji = {
        #     ".0": "0ï¸âƒ£",
        #     ".1": "1ï¸âƒ£",
        #     ".2": "2ï¸âƒ£",
        #     ".3": "3ï¸âƒ£",
        #     ".4": "4ï¸âƒ£",
        #     ".5": "5ï¸âƒ£",
        #     ".6": "6ï¸âƒ£",
        #     ".7": "7ï¸âƒ£",
        #     ".8": "8ï¸âƒ£",
        #     ".9": "9ï¸âƒ£",
        #     ".#": "#ï¸âƒ£",
        #     ".*": "*ï¸âƒ£",
        #     ".!": "âœ…",
        #     ".a": "ğŸ“Œ",
        #     ".b": "ğŸ“–",
        #     ".c": "ğŸ“",
        #     ".d": "ğŸ’¡",
        #     ".e": "ğŸ”¸",
        #     ".f": "ğŸ”¹",
        #     ".g": "âš ï¸",
        #     ".h": "âš¡ï¸",
        #     ".i": "â­ï¸",
        #     ".j": "ğŸ”¥",
        # }
        # # emoji = {k: v.strip("\ufe0f") for k, v in emoji.items()}
        # s = getClipboardText()
        # # s = s.translate(str.maketrans(emoji))
        # pairs = re.split("(..)", s)[1::2]
        # s = "".join(emoji.get(pair, "") for pair in pairs)
        # paste_string(s)
        #
        # ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ä¸Šæ‰‹ãã„ã‹ãªã„ã®ã§PowerShellã§å®Ÿè¡Œ.
        # (setClipboardTextã™ã‚‹ã¨ãŠã‹ã—ããªã‚‹)
        shell_mini("pwsh.exe", '-nop -f "C:\\Users\\{user}\\convert_to_emoji.ps1"')()

    def url_encode():
        paste_string(urllib.parse.quote(getClipboardText(), safe=""))

    def url_decode():
        paste_string(urllib.parse.unquote(getClipboardText()))

    def next_chrome_window():
        dbg(">>>>> next_chrome_window <<<<<")

        def getWindowList(wnd, arg):
            if not wnd.isVisible():
                return True
            # if not wnd.getOwner():
            #     return True
            if wnd.getText() == "":
                return True
            # dbg(wnd.getProcessName())
            if re.match(r"chrome", wnd.getProcessName()):
                window_list.append(wnd)
            # if re.match(r"chrome", wnd.getClassName()):
            #     window_list.append(wnd)
            # window_list.append(wnd)
            return True

        now = time.time_ns() / 1_000_000  # ms
        history = sorted(mysetting.chrome_history, key=lambda x: x[1], reverse=True)
        if len(history) > 0:
            dbg("{}".format(now - history[0][1]))
            if now - history[0][1] > 5_000:  # 5s
                dbg("clear chrome history")
                mysetting.chrome_history = []
                history = []

        if mysetting.debug:
            for entry in history:
                dbg(f"{entry[0]}, {entry[1]}")

        next_window = (None, -1)
        window_list = []
        Window.enum(getWindowList, None)
        current_wnd_text = keymap.getTopLevelWindow().getText()
        dbg(f"[current] {current_wnd_text}")
        for wnd in window_list:
            text = wnd.getText()
            if current_wnd_text == text:
                continue
            idx = [i for i, e in enumerate(history) if e[0] == text]
            if len(idx) > 0:
                if next_window[1] < idx[0]:
                    dbg(f"found in history: {text}({idx[0]})")
                    next_window = (wnd, idx[0])
            else:
                dbg(f"not found in history: {text}")
                next_window = (wnd, len(history))
                break

        if next_window[0]:
            dbg("[next] " + next_window[0].getText())
            mysetting.chrome_history.append((next_window[0].getText(), now))
            next_window[0].setForeground()

    def truncate(string, length, ellipsis="..."):
        return string[:length] + (ellipsis if string[length:] else "")

    def truncate_cjk(string, length, ellipsis="..."):
        # http://www.unicode.org/reports/tr11/
        count = 0
        text = ""
        for c in string:
            if unicodedata.east_asian_width(c) in "FWA":
                count += 2
            else:
                count += 1

            if count > length:
                text += ellipsis
                break
            text += c
        return text

    def switch_windows():
        dbg(">>>>> switch_windows <<<<<")

        def popWindowList():
            # If the list window is already opened, just close it
            if keymap.isListWindowOpened():
                keymap.cancelListWindow()
                return

            def getWindowList(wnd, arg):
                if not wnd.isVisible():
                    return True
                # if not wnd.getOwner():
                #     return True
                if wnd.getText() == "":
                    return True
                dbg(wnd.getProcessName())
                dbg("  " + wnd.getClassName())
                dbg("    " + wnd.getText())
                if re.match(
                    r"(keyhac|DesktopTicker|SystemSettings|ApplicationFrameHost|TextInputHost|explorer|onenoteim)\.exe",
                    wnd.getProcessName(),
                ):
                    dbg("(pass)")
                    return True
                # if re.match(r"chrome", wnd.getClassName()):
                #     window_list.append(wnd)
                window_list.append(wnd)
                return True

            window_list = []
            Window.enum(getWindowList, None)

            popup_list = [
                ("{:>20s} :: {}".format(truncate(i.getProcessName()[:-4], 17), truncate_cjk(i.getText(), 45)), i)
                for i in sorted(window_list, key=lambda x: x.getProcessName())
            ]

            if mysetting.debug:
                for i in popup_list:
                    dbg(i[0])

            listers = [("Windows", cblister_FixedPhrase(popup_list))]
            item, mod = keymap.popListWindow(listers)
            if item:
                item[1].setForeground()

        # Because the blocking procedure cannot be executed in the key-hook,
        # delayed-execute the procedure by delayedCall().
        keymap.delayedCall(popWindowList, 0)



    # Setting with program file path (Simple usage)
    keymap.editor = "code"

    # Font
    keymap.setFont("Sarasa Fixed Slab J Semibold", 24)

    # Theme
    keymap.setTheme("black")

    # Simple key replacement
    keymap.replaceKey("(29)", 235)  # ç„¡å¤‰æ›
    keymap.replaceKey("(28)", 236)  # å¤‰æ›

    # User modifier key definition
    keymap.defineModifier(235, "User0")
    keymap.defineModifier(236, "User1")

    # Global keymap which affects any windows
    keymap_global = keymap.defineWindowKeymap()
    keymap.quote_mark = "> "  # Mark for quote pasting

    keymap_global["S-RCtrl"] = cursor_to_center
    keymap_global["C-RCtrl"] = window_to_center
    keymap_global["U0-RCtrl"] = window_to_cursor
    keymap_global["U0-Space"] = switch_windows
    keymap_global["U0-F7"] = next_chrome_window
    keymap_global["U0-F8"] = window_to_center_force
    keymap_global["U0-F9"] = shell(
        "C:\\Program Files\\Google\\Chrome\\Application\\Chrome.exe",
        "--new-window https://www.google.com/webhp?hl=ja",
    )
    keymap_global["U0-Right"] = ikey("S-A-Right", "S-A-Right")

    def switch_zulip():
        wnd = find_window("^Zulip")
        if wnd:
            foreground_window(wnd)
        else:
            dbg("(start zulip.)")
            shell("C:\\Users\\{user}\\AppData\\Local\\Programs\\zulip\\Zulip.exe")()

    keymap_global["U0-M"] = switch_zulip
    keymap_global["U0-P"] = keymap.defineMultiStrokeKeymap("PARENTHES: [1]ã€Šã€‹ [2]ã€ˆã€‰ [3]ã€”ã€• [4]ã€ã€ [5]ã€ã€‘ [6]ï¼ˆï¼‰ [7]()")
    for key, args in {
        "1": ["ã€Šã€‹", "Left"],
        "2": ["ã€ˆã€‰", "Left"],
        "3": ["ã€”ã€•", "Left"],
        "4": ["ã€ã€", "Left"],
        "5": ["ã€ã€‘", "Left"],
        "6": ["ï¼ˆï¼‰", "Left"],
        "7": ["()", "Left"],
    }.items():
        keymap_global["U0-P"][key] = ime_input1(*args)

    def input_date(fmt):
        def _input_data():
            d = datetime.datetime.today()
            date_str = d.strftime(fmt)
            set_ime(0)
            send_input(date_str, 0)

        return _input_data

    keymap_global["U0-D"] = keymap.defineMultiStrokeKeymap("DATE: [1]YMD, [2]Y/M/D, [3]Y-M-D")
    for key, args in {
        "1": ["%Y%m%d"],
        "2": ["%Y/%m/%d"],
        "3": ["%Y-%m-%d"],
    }.items():
        keymap_global["U0-D"][key] = input_date(*args)

    keymap_global["U0-8"] = ime_context(ime_input0("S-8"))
    keymap_global["U0-9"] = ime_context(ime_input0("S-9"))
    keymap_global["U0-OpenBracket"] = ime_context(ime_input0("OpenBracket"))
    keymap_global["U0-CloseBracket"] = ime_context(ime_input0("CloseBracket"))
    keymap_global["U0-Slash"] = ime_context(ime_input0("Slash"))

    def splitlines_with_period():
        s = get_current_clipboard()
        s = s.replace("\r\n", "").split(".")
        s = ".\r\n".join(list(map(str.strip, s)))
        paste_string(s)

    def remove_bullet():
        paste_string(get_current_clipboard().replace(" âˆ™ ", " ").replace("âˆ™", ""))

    def remove_breaklines():
        paste_string(get_current_clipboard().replace("\r\n", ""))

    def remove_breaklines_with_trim():
        paste_string("".join(list(map(str.strip, get_current_clipboard().split("\r\n")))))

    def replace_zenkaku_punctuation():
        paste_string(get_current_clipboard().replace("ï¼", "ã€‚"))

    def stanza_runner():
        paste_string('p ./stanza_runner.py "{}"'.format(get_current_clipboard().replace('"', '""')))

    def stanza_displacy():
        paste_string('p ./stanza_displacy.py "{}"'.format(get_current_clipboard().replace('"', '""')))

    def convert_google_drive_image_url():
        # https://drive.google.com/open?id=XXXX&authuser=xxx.gmail.com&usp=drive_fs
        # -> https://drive.google.com/file/d/XXXX/view
        s = getClipboardText()
        result = re.match("https://.+open\?id=(\w+)", s)
        if result:
            paste_string("https://drive.google.com/file/d/{0}/view".format(result.group(1)))

    # Return formatted date-time string
    def date_and_time(fmt, d):
        return (datetime.datetime.now() + datetime.timedelta(d)).strftime(fmt)

    def gen_uuid():
        s = getClipboardText()
        uid = str(uuid.uuid5(uuid.uuid1(), s))
        paste_string(uid.replace("-", ""))

    def gen_uuid8():
        s = getClipboardText()
        uid = str(uuid.uuid5(uuid.uuid1(), s))
        paste_string(uid[0:8])

    def command_PopCommandList():
        # If the list window is already opened, just close it
        if keymap.isListWindowOpened():
            keymap.cancelListWindow()
            return

        def popCommandList():
            commands = [
                ("  :splitlines_with_period", splitlines_with_period),
                ("  :remove_bullet", remove_bullet),
                ("  :remove_breaklines", remove_breaklines),
                ("  :remove_breaklines_with_trim", remove_breaklines_with_trim),
                ("  :replace_zenkaku_punctuation", replace_zenkaku_punctuation),
                ("1 :stanza_runner", stanza_runner),
                ("  :stanza_displacy", stanza_displacy),
                ("  :number_to_half_width", number_to_half_width),
                ("  :number_to_full_width", number_to_full_width),
                ("  :to_emoji", to_emoji),
                ("  :url_encode", url_encode),
                ("  :url_decode", url_decode),
                ("  :uuid", gen_uuid),
                ("  :uuid8", gen_uuid8),
                ("  :config(edit)", keymap.command_EditConfig),
                ("  :config(reload)", keymap.command_ReloadConfig),
                ("  :convert_google_drive_image_url", convert_google_drive_image_url),
                ("  ^since:today", itext("since:" + date_and_time("%Y-%m-%d", 0))),
                ("  ^since:yesterday", itext("since:" + date_and_time("%Y-%m-%d", -1))),
            ]

            listers = [("Commmand", cblister_FixedPhrase(commands))]

            item, mod = keymap.popListWindow(listers)

            if item:
                item[1]()

        # Because the blocking procedure cannot be executed in the key-hook,
        # delayed-execute the procedure by delayedCall().
        keymap.delayedCall(popCommandList, 0)

    keymap_global["U0-AtMark"] = command_PopCommandList

    def command_PopHistoryList():
        # If the list window is already opened, just close it
        if keymap.isListWindowOpened():
            keymap.cancelListWindow()
            return

        def popHistoryList():
            def direct_paste(s):
                def _direct_paste():
                    paste_string(s)

                return _direct_paste

            histories = []
            items = keymap.clipboard_history.getListItems()
            for i, item in enumerate(items):
                histories.append(("{}: {}".format((i + 1) % 10, item[0]), direct_paste(item[1])))
            for i, item in enumerate(mysetting.phrase):
                histories.append(("{}: {}".format(chr(ord("a") + i), item[0]), direct_paste(item[1])))

            listers = [("Clipboard", cblister_FixedPhrase(histories))]
            item, mod = keymap.popListWindow(listers)
            if item:
                item[1]()

        # Because the blocking procedure cannot be executed in the key-hook,
        # delayed-execute the procedure by delayedCall().
        keymap.delayedCall(popHistoryList, 0)

    keymap_global["U0-Semicolon"] = command_PopHistoryList

    def lw_search():
        ikey("F")()
        mysetting.lw_search_mode = True

    def lw_exit():
        if mysetting.lw_search_mode:
            ikey("Esc", "Esc")()
        else:
            ikey("Esc")()

    def is_list_window(window):
        if window.getClassName() == "KeyhacWindowClass" and window.getText() != "Keyhac":
            mysetting.lw_search_mode = False
            return True
        else:
            return False

    keymap_lw = keymap.defineWindowKeymap(check_func=is_list_window)
    keymap_lw["U0-N"] = ikey("Down")
    keymap_lw["U0-P"] = ikey("Up")
    keymap_lw["U0-AtMark"] = lambda: [window_to_center(), lw_search()]
    keymap_lw["U0-Space"] = lambda: [window_to_center(), lw_search()]
    keymap_lw["U0-Semicolon"] = lambda: [window_to_center(), lw_search()]
    keymap_lw["Enter"] = ikey("Enter", "Enter")
    keymap_lw["Escape"] = lw_exit

    # Customizing clipboard history list

    # Enable clipboard monitoring hook (Default:Enabled)
    keymap.clipboard_history.enableHook(True)

    # Maximum number of clipboard history (Default:1000)
    keymap.clipboard_history.maxnum = 10

    # Total maximum size of clipboard history (Default:10MB)
    keymap.clipboard_history.quota = 10 * 1024 * 1024
```

`{user}`ã¯ã€Windowsã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åã«ç½®ãæ›ãˆã¦ãã ã•ã„ï¼ã¾ãŸã€çµµæ–‡å­—ã‚’å¤‰æ›ã™ã‚‹PowerShellã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯æ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ï¼

```powershell title=convert_to_emoji.ps1
$emoji = @{
    "0"= "0ï¸âƒ£"
    "1"= "1ï¸âƒ£"
    "2"= "2ï¸âƒ£"
    "3"= "3ï¸âƒ£"
    "4"= "4ï¸âƒ£"
    "5"= "5ï¸âƒ£"
    "6"= "6ï¸âƒ£"
    "7"= "7ï¸âƒ£"
    "8"= "8ï¸âƒ£"
    "9"= "9ï¸âƒ£"
    "#"= "#ï¸âƒ£"
    "*"= "*ï¸âƒ£"
    "!"= "âœ…"
    "a"= "ğŸ“Œ"
    "b"= "ğŸ“–"
    "c"= "ğŸ“"
    "d"= "ğŸ’¡"
    "e"= "ğŸ”¸"
    "f"= "ğŸ”¹"
    "g"= "âš ï¸"
    "h"= "âš¡ï¸"
    "i"= "â­ï¸"
    "j"= "ğŸ”¥"
}
$chars = Get-Clipboard
$result = ""
foreach ($_ in $chars.ToCharArray()) {
    if ($emoji.ContainsKey("${_}")) {
        $result += $emoji["${_}"];
    } else {
        $result += $_;
    }
}
Set-Clipboard $result
```

ä»¥ä¸Šã§ã™ï¼Keyhacã¯ã¨ã¦ã‚‚ä¾¿åˆ©ãªã®ã§ã€èˆˆå‘³ãŒã‚ã‚Œã°ä½¿ã£ã¦ã¿ã¦ãã ã•ã„ï¼