<!DOCTYPE html>
<html lang="en">
  <head>
    <title>EffectTextureMaker</title>
    <meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #fff;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;
        font-weight: bold;
        
        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }
      
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
      }
      
      #info {
        position: absolute;
        padding: 10px;
        width: 100%;
        text-align: center;
        color: #fff;
      }
      
      a { color: orange; }
    </style>
  </head>
  <body>
    <div id="info">
      EffectTextureMaker - Powered by <a href="http://threejs.org" target="_blank">three.js</a> - <a href="http://mebiusbox.github.io/contents/EffectTextureMaker/README.html">About</a><br />
      <br />
      Special thanks to doxas, liovch, iq, KeyMaster-, knighty, XT95, Brandon Fogerty, FabriceNeyret2, TambakoJaguar, mu6k, anisoptera, namortrailblazer, vamoss, xbe, Iulian Marinescu Ghetau, Duke, hclarke, 104, vchizhov, smkgames, Stefan Gustavson, skaplun, Koltes, arxyz, diviaki, Sunpy, Hadyn, Dave_Hoskins, maysssam, joltz0r
      <div id="time" style="font-family: consolas; margin-top: 8px;">
  		</div>
    </div>
    <div id="inspector" style="position:absolute; left: 10px; top: 100px; width: 200px; height: 100px; font-family: consolas;">
		</div>
    <script src="js/three.min.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/shaders/CopyShader.js"></script>
    <script src="js/pixy.min.js"></script>
    <script>
      if (THREE.WEBGL.isWebGLAvailable() === false) {
        document.body.appendChild(THREE.WEBGL.getWebGLErrorMessage());
      }
      
      var mouse = new THREE.Vector2(0.5, 0.5);
      var canvas;
      var camera, dummyCamera, controls, scene, renderer;
      var noiseScene, noiseSphere, noiseUniforms, noiseMaterial, noiseTexture;
      var grungeTexture;
      var gui, guiTiling, guiTone, guiNormalMap, guiCB, guiPars, guiParsItems = [], stats, clock = new THREE.Clock();
      var effectController;
      var layers = [];
      var spriteSheet = {};
      var post = {};
      
      var noise;
      var defines;
      
      // Save Helper
      
      var link = document.createElement( 'a' );
    	link.style.display = 'none';
    	document.body.appendChild( link ); // Firefox workaround, see #6594

    	function save( blob, filename ) {
    		link.href = URL.createObjectURL( blob );
    		link.download = filename || 'data.json';
    		link.click();
    		// URL.revokeObjectURL( url ); breaks Firefox...
    	}

    	function saveString( text, filename ) {
    		save( new Blob( [ text ], { type: 'text/plain' } ), filename );
    	}
      
      init();
      // render();
      animate();
      
      function init() {
        
        initGraphics();
        initScene();
        // initPost();
        setupGui();
        initLayers();
        
        // EVENTS
        
        window.addEventListener('resize', onWindowResize, false);
      }
      
      function initGraphics() {
        // RENDERER
        
        renderer = new THREE.WebGLRenderer();
        // renderer = new THREE.WebGLRenderer({antialias: true});
        // renderer.setClearColor(0xAAAAAA);
        // renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(512, 512);
        // renderer.setSize(window.innerWidth, window.innerHeight);
        // renderer.gammaInput = true;
        // renderer.gammaOutput = true;
        // renderer.autoClear = false;
        // container.appendChild(renderer.domElement);
        renderer.getContext().getExtension('OES_standard_derivatives');
        canvas = renderer.domElement;
        canvas.addEventListener('mousemove', onMouseMove);
        document.body.appendChild(canvas);
        
        // STATS
        
        stats = new Stats();
				document.body.appendChild(stats.dom);
      }
      
      function initScene() {
        
        // scene itself
        scene = new THREE.Scene();
        noiseScene = new THREE.Scene();
        
        // CAMERA
        
        camera = new THREE.PerspectiveCamera(45.0, 1.0, 1.0, 1000.0);
        camera.position.set(0.0, 0.0, 3.8);
        // camera.lookAt(new THREE.Vector3(0.0, -0.3, 1.0));
        dummyCamera = new THREE.Camera();
        
        // CONTROLS
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0,0,0);
        controls.addEventListener('change', render);
        
        // TEXTUERS
        
        // MATERIALS
        
        // MODELS
        
        var geo = new THREE.PlaneBufferGeometry(2, 2);
        var mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial());
        scene.add(mesh);
        
        // TEXTUER MAP
        // Noise Texture (for CLOUDS)
        // noiseTexture = new THREE.TextureLoader().load('assets/textures/shadertoy/tex16.png');
        // noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
        // noiseTexture.minFilter = THREE.Linear;
        // noiseTexture.magFilter = THREE.Linear;
        // noiseTexture.anisotropy = 16;
        
        // Grunge Texture
        grungeTexture = new THREE.TextureLoader().load('images/grunge.png');
        grungeTexture.wrapS = grungeTexture.wrapT = THREE.RepeatWrapping;
        grungeTexture.minFilter = THREE.Linear;
        grungeTexture.magFilter = THREE.Linear;
        grungeTexture.anisotropy = 16;
        
        geo = new THREE.SphereBufferGeometry(1, 1024, 1024);
        
        var stdShader = new PIXY.FxgenShader();
        stdShader.enable("DISPLACEMENT");
        noiseUniforms = stdShader.generateUniforms();
        noiseMaterial = stdShader.createStandardMaterial(noiseUniforms);
        noiseSphere = new THREE.Mesh(geo, noiseMaterial);
        noiseScene.add(noiseSphere);
        // console.log(stdShader.generateVertexShader());
        // console.log(stdShader.generateFragmentShader());


        // LAYERS
        
        noise = {};
        noise.octave = 8;
        noise.persistence = 0.5;
        
        var stdShader = new PIXY.FxgenShader();
        defines = stdShader.generateDefines();
        
        spriteSheet.uniforms = THREE.UniformsUtils.clone(THREE.CopyShader.uniforms);
        spriteSheet.material = new THREE.ShaderMaterial({
          uniforms: spriteSheet.uniforms,
          vertexShader: THREE.CopyShader.vertexShader,
          fragmentShader: THREE.CopyShader.fragmentShader,
          depthTest: false,
          depthWrite: false});
        // spriteSheet.uniforms.tDiffuse.value = spriteSheet.renderTarget.texture;
        spriteSheet.uniforms.opacity.value = 1.0;
        
        spriteSheet.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        spriteSheet.scene = new THREE.Scene();
        spriteSheet.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), spriteSheet.material);
        spriteSheet.dimension = 8;
        spriteSheet.time = 0.0;
        spriteSheet.timeLength = 3.0;
        spriteSheet.timeStep = 0.1;
        spriteSheet.scene.add(spriteSheet.quad);
      }
      
      function initLayers() {
        
        layers = [];
        
        var layer = {};
        
        layer.name = "Base";
        // layer.renderTarget = null;
        layer.renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false });
        
        var stdShader = new PIXY.FxgenShader();
        var type = effectController.type;
        stdShader.enable(type.toUpperCase());
        stdShader.enable("TOON");
        layer.uniforms = stdShader.generateUniforms();
        layer.material = stdShader.createMaterial(layer.uniforms, { defines: defines });
        // console.log(stdShader.generateVertexShader());
        // console.log(stdShader.generateFragmentShader());
        
        resetParameters(layer.uniforms);
        layers.push(layer);
        
        //// POLAR CONVERSION
        
        layer = {};
        layer.name = "PolarConversion";
        layer.tDiffuse = layers[layers.length-1].renderTarget.texture;
        layer.renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false });
        
        stdShader.clear();
        stdShader.enable("POLARCONVERSION");
        layer.uniforms = stdShader.generateUniforms();
        layer.material = stdShader.createMaterial(layer.uniforms, { defines: defines });
        layers.push(layer);
        
        //// COLOR BALANCE
        
        layer = {};
        layer.name = "ColorBalance";
        layer.tDiffuse = layers[layers.length-1].renderTarget.texture;
        layer.renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false });
        
        stdShader.clear();
        stdShader.enable("COLORBALANCE");
        layer.uniforms = stdShader.generateUniforms();
        layer.material = stdShader.createMaterial(layer.uniforms, { defines: defines });
        // console.log(stdShader.generateVertexShader());
        // console.log(stdShader.generateFragmentShader());
        layers.push(layer);

        //// TILING
        
        layer = {};
        layer.name = "Tiling";
        layer.tDiffuse = layers[layers.length-1].renderTarget.texture;
        layer.tDiffuse.wrapS = layer.tDiffuse.wrapT = THREE.RepeatWrapping;
        layer.renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height, {
          minFilter: THREE.NearestFilter,
          magFilter: THREE.NearestFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false });
        
        stdShader.clear();
        stdShader.enable("TILING");
        layer.uniforms = stdShader.generateUniforms();
        layer.material = stdShader.createMaterial(layer.uniforms, { defines: defines });
        // console.log(stdShader.generateVertexShader());
        // console.log(stdShader.generateFragmentShader());
        layers.push(layer);
        
        //// NORMAL MAP
        
        layer = {};
        layer.name = "NormalMap";
        layer.tDiffuse = layers[layers.length-1].renderTarget.texture;
        layer.renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false });
        
        stdShader.clear();
        // stdShader.enable("HEIGHT2NORMAL");
        stdShader.enable("HEIGHT2NORMALSOBEL");
        layer.uniforms = stdShader.generateUniforms();
        layer.material = stdShader.createMaterial(layer.uniforms, { defines: defines });
        layers.push(layer);
        
        //// COPY
        
        layer = {};
        layer.name = "Copy";
        layer.tDiffuse = layers[layers.length-1].renderTarget.texture;
        layer.renderTarget = null;
        
        stdShader.clear();
        stdShader.enable("COPY");
        layer.uniforms = stdShader.generateUniforms();
        layer.material = stdShader.createMaterial(layer.uniforms, { defines: defines });
        layers.push(layer);
        
        spriteSheet.renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false });
      }
      
      // EVENT HANDLERS
      
      function onWindowResize() {
        
        console.log("onWindowResize");
        renderer.setSize(canvas.width, canvas.height);
        
        if (layers) {
          for (var i=0; i<layers.length; i++) {
            if (layers[i].renderTarget) {
              layers[i].renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height,
                {
                  minFilter: THREE.LinearFilter, 
                  magFilter: THREE.LinearFilter,
                  format: THREE.RGBFormat,
                  stencilBuffer: false
                });
            }
            if (layers[i].tDiffuse) {
              layers[i].tDiffuse = layers[i-1].renderTarget.texture;
            }
            if (layers[i].name === "Tiling") {
                layers[i].tDiffuse.wrapS = layers[i].tDiffuse.wrapT = THREE.RepeatWrapping;
            }
          }
        }
        
        spriteSheet.renderTarget = new THREE.WebGLRenderTarget(canvas.width, canvas.height, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false });
        
        // camera.aspect = window.innerWidth / window.innerHeight;
        // camera.updateProjectionMatrix();
        
        render();
      }
      
      function onMouseMove(e) {
        mouse.x = e.offsetX / canvas.width;
        mouse.y = e.offsetY / canvas.height;
      }
      
      function setupGui() {
        
        fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.addEventListener('change', function(event) {
          var reader = new FileReader();
          reader.addEventListener('load', function(event) {
            var contents = event.target.result;
            var json = JSON.parse(contents);
            
            canvas.width  = json.resolution;
            canvas.height = json.resolution;
            onWindowResize();
            
            var stdShader = new PIXY.FxgenShader();
            stdShader.enable(json.type.toUpperCase());
            stdShader.enable("TOON");
            layers[0].uniforms = stdShader.generateUniforms();
            layers[0].material = stdShader.createMaterial(layers[0].uniforms, { defines: stdShader.generateDefines()});
            
            effectController.type = json.type;
            resetParameters(layers[0].uniforms);
            
            for (var i in json) {
              effectController[i] = json[i];
            }
            for (var i in gui.__controllers) {
              gui.__controllers[i].updateDisplay();
            }
            for (var i in guiPars.__controllers) {
              guiPars.__controllers[i].updateDisplay();
            }
            for (var i in guiTone.__controllers) {
              guiTone.__controllers[i].updateDisplay();
            }
            for (var i in guiTiling.__controllers) {
              guiTiling.__controllers[i].updateDisplay();
            }
            for (var i in guiNormalMap.__controllers) {
              guiNormalMap.__controllers[i].updateDisplay();
            }
            for (var i in guiCB.__controllers) {
              guiCB.__controllers[i].updateDisplay();
            }
            
          }, false);
          reader.readAsText(fileInput.files[ 0 ]);
        });
        fileInput.addEventListener('click', function(event) {
          this.value = null;
        });
        
        effectController = {
          saveImage: function() {
            render();
            // window.open(canvas.toDataURL());
            var dataUrl = canvas.toDataURL();
            var w = window.open('about:blank');
            w.document.write("<img src='" + dataUrl + "'/>");
          },
          
          saveSpriteSheet: function() {
            
            var width = Math.floor(canvas.width / spriteSheet.dimension);
            var size = width / canvas.width;
            var time = spriteSheet.time;
            // var time = 0.0;
            
            renderer.setRenderTarget(spriteSheet.renderTarget);
            renderer.clear();
            renderer.setRenderTarget(null);
            
            for (var i=0; i<spriteSheet.dimension; i++) {
              for (var j=0; j<spriteSheet.dimension; j++) {
                
                var len = spriteSheet.timeStep * spriteSheet.dimension * i + spriteSheet.timeStep * j;
                if (len >= spriteSheet.timeLength) {
                  break;
                }
                
                effectController.time = time + len;
                render();
                
                spriteSheet.uniforms.tDiffuse.value = layers[layers.length-2].renderTarget.texture;

                spriteSheet.quad.scale.set(size, size, 1.0);
                spriteSheet.quad.position.set(-1 + 2.0 * size * j + size, 1 - 2.0 * size * i - size, 0.0);
                
                renderer.autoClear = false;
                renderer.setRenderTarget(spriteSheet.renderTarget);
                renderer.render(spriteSheet.scene, spriteSheet.camera);
                renderer.setRenderTarget(null);
                renderer.autoClear = true;
              }
            }
            
            spriteSheet.quad.scale.set(1.0, 1.0, 1.0);
            spriteSheet.quad.position.set(0.0, 0.0, 0.0);
            spriteSheet.uniforms.tDiffuse.value = spriteSheet.renderTarget.texture;
            renderer.render(spriteSheet.scene, spriteSheet.camera);
            
            effectController.time = time;
            // window.open(canvas.toDataURL());
            var dataUrl = canvas.toDataURL();
            var w = window.open('about:blank');
            w.document.write("<img src='" + dataUrl + "'/>");
          },
          
          resetColorBalance: function() {
            effectController.cColorBalanceShadowsR = 0.0;
            effectController.cColorBalanceShadowsG = 0.0;
            effectController.cColorBalanceShadowsB = 0.0;
            effectController.cColorBalanceMidtonesR = 0.0;
            effectController.cColorBalanceMidtonesG = 0.0;
            effectController.cColorBalanceMidtonesB = 0.0;
            effectController.cColorBalanceHighlightsR = 0.0;
            effectController.cColorBalanceHighlightsG = 0.0;
            effectController.cColorBalanceHighlightsB = 0.0;
            for (var i in guiCB.__controllers) {
              guiCB.__controllers[i].updateDisplay();
            }
          },
          
          load: function() {
            fileInput.click();
          },
          
          save: function() {
            var output;
            try {
        			output = JSON.stringify( effectController, parseNumber, '\t' );
        			output = output.replace( /[\n\t]+([\d\.e\-\[\]]+)/g, '$1' );
        		} catch ( e ) {
        			output = JSON.stringify( effectController );
        		}
            saveString( output, 'EffectTextureMaker_Untitled.json' );
          },
          
          animate: false,
          time: 0.0,
          
          // freeCamera: false,
          resolution: '512',
          polarConversion: false,
          
          cHeightScale: 2.0,
          normalMap: false,
          tiling: false,
          cRadialMask: 1.0,
          
          //MARK: parameters
          cFrequency: 30.0,
          cAmplitude: 0.01,
          cIntensity: 0.5,
          cDirectionX: 0.0,
          cDirectionY: 1.0,
          cPowerExponent: 1.0,
          cRadius: 1.0,
          cInnerRadius: 1.0,
          cInnerRadius2: 1.0,
          cSize: 1.0,
          cWidth: 1.0,
          cHeight: 1.0,
          cDepth: 1.0,
          cColor: 1.0,
          cRadius: 0.5,
          cPetals: 6.0,
          cOffset: 0.2,
          cVolume: 3.0,
          cBeta: 4.0,
          cDelta: 0.05,
          cScale: 1.0,
          cInnerWidth: 0.4,
          cStrength: 1.0,
          cPower: 1.0,
          cRange: 2.0,
          cEmission: 1.0,
          cBloom: 1.0,
          cLightX: 1.0,
          cLightY: 1.0,
          cLightZ: 1.0,
          cAmbient: 1.0,
          cSmoothness: 1.0,
          cSmoothnessPower: 1.0,
          cThickness: 1.0,
          cThicknessPower: 1.0,
          cCameraTilt: 0.0,
          cCameraPan: 0.0,
          cSpeed: 1.0,
          cAngle: 0.0,
          cDensity: 1.0,
          cAlpha: 1.0,
          
          cDiamondGearTeeth: 18.0,
          cDiamondGearMid: 0.8,
          
          cBrushStrokeX1: -0.4,
          cBrushStrokeY1: 0.0,
          cBrushStrokeX2: 1.1,
          cBrushStrokeY2: 0.8,
          
          cBubblesVariation: 1.0,
          
          cFlameEyeInnerFade: 1.0,
          cFlameEyeOuterFade: 1.0,
          cFlameEyeBorder: 1.0,
          
          cSplatLines: 20,
          cSplatSpotStep: 0.04,

          cTrabeculumVariation: 2.0,

          cLifeTime: 0.9,
          cGravity: 0.26,          
          cCount: 300,
          
          // circleRadius: 1.1,
          // ringRadius: 0.5,
          // ringWidth: 0.1,
          // flowerPetals: 6.0,
          // flowerRadius: 0.5,
          // flowerOffset: 0.2,
          // gradationOffset: 0.0001,
          // smokeVolume: 3.0,
          // smokeBeta: 4.0,
          // smokeDelta: 0.05,
          // flameWidth: 1.0,
          // flameScale: 1.0,
          // cellSize: 1.0,
          // lightningFrequency: 1.0,
          // lightningWidth: 7.0,
          // coronaRadius: 0.3,
          // coronaSize: 1.0,
          // 
          // lensFlareRadius: 1.0,
          // lensFlareLength: 1.0,
          // lensFlareColor: 0.0,
          // 
          // sunRadius: 1.0,
          // sunColor: 0.0,
          // 
          // laserWidth: 0.5,
          // laserInnerWidth: 0.4,
          // laserColor: 1.0,
          
          cToonEnable: false,
          cToonDark: 0.8,
          cToonLight: 0.95,
          
          // fireStrength: 1.0,
          // firePower: 1.0,
          // fireRange: 2.0,
          // fireWidth: 0.1,
          // fireColor: 0.0001,
          
          cExplosionRadius: 1.75,
          cExplosionDownScale: 1.25,
          cExplosionGrain: 2.0,
          cExplosionSpeed: 0.3,
          cExplosionBallness: 2.0,
          cExplosionGrowth: 2.2,
          cExplosionFade: 1.6,
          cExplosionDensity: 1.35,
          cExplosionContrast: 1.0,
          cExplosionRollingInitDamp: 0.3,
          cExplosionRollingSpeed: 2.0,
          cExplosionDelayRange: 0.25,
          cExplosionBallSpread: 1.0,
          cExplosionBloom: 0.0,
          cExplosionEmission: 0.2,
          cExplosionColor: 1.0,
          
          cNoiseOctave: 8,
          cNoiseFrequency: 1.0,
          cNoiseAmplitude: 0.65,
          cNoisePersistence: 0.5,
          cNoiseScale: 1.0,
          cNoiseSphereEnable: false,
          cNoiseGraphEnable: false,
          cNoiseStrength: 1.0,
          cNoiseDepth: 3,
          cNoiseSize: 8.0,
          
          cColorBalanceShadowsR: 0.0,
          cColorBalanceShadowsG: 0.0,
          cColorBalanceShadowsB: 0.0,
          cColorBalanceMidtonesR: 0.0,
          cColorBalanceMidtonesG: 0.0,
          cColorBalanceMidtonesB: 0.0,
          cColorBalanceHighlightsR: 0.0,
          cColorBalanceHighlightsG: 0.0,
          cColorBalanceHighlightsB: 0.0,
          
          type: "Wood",
          // type: "Test",
        };
        
        var h;
        gui = new dat.GUI();
        gui.add(effectController, 'load');
        gui.add(effectController, 'save');
        
        // material (attributes)
        
        h = gui;
        
        // Parameters
        
        // h.add(effectController, 'freeCamera');
        h.add(effectController, 'resolution', ['8', '16', '32', '64', '128', '256', '512', '1024', '2048']).onChange(function(value) {
          canvas.width = value;
          canvas.height = value;
          onWindowResize();
        });
        
        //MARK: type
        h.add(effectController, "type", [
          "Wood", "Circle", "Solar", "Corona", "Spark", "Ring", "Gradation", "GradationLine", "Flash", "Cone", "Flower", "FlowerFun", "WaveRing", "Smoke", "Flame", "FlameEye", "Fire", "Cell", "Lightning", "Flare", "Flare2", "Flare3", "LensFlare", "Sun", "MagicCircle", "Mandara",
          "Explosion", "Explosion2", "Cross", "Laser", "Laser2", "Light", "Cloud", "Cloud2", 
          "PerlinNoise", "SeemlessNoise", "BooleanNoise", "CellNoise", "TurbulentNoise", 
          "FbmNoise", "FbmNoise2", "FbmNoise3", 
          "RandomNoise", "VoronoiNoise", "SparkNoise", "MarbleNoise", "TessNoise", "GradientNoise",
          "Checker", "FlameLance", "Bonfire", "Snow", "DiamondGear", "BrushStroke",
          "Speckle", "Bubbles", "Pentagon", "Grunge", "Energy", "InkSplat", "Particle", "Electric",
          "Caustics", "Squiggles", "WaterTurbulence", "Trabeculum"
          
        ]).onChange(function(value) {
          
          var stdShader = new PIXY.FxgenShader();
          stdShader.enable(value.toUpperCase());
          stdShader.enable("TOON");
          layers[0].uniforms = stdShader.generateUniforms();
          layers[0].material = stdShader.createMaterial(layers[0].uniforms, { defines: stdShader.generateDefines()});
          // console.log(stdShader.generateVertexShader());
          // console.log(stdShader.generateFragmentShader());
          
          resetParameters(layers[0].uniforms);
        });
        
        gui.add(effectController, "time", 0, 100.0);
        gui.add(effectController, "animate");
        
        guiPars = gui.addFolder("Parameters");
        guiParsItems = [];
        // resetParameters();
        
        h = gui.addFolder("Toon");
        h.add(effectController, "cToonEnable").name("enable");
        h.add(effectController, "cToonDark", 0.0, 1.0).name("dark");
        h.add(effectController, "cToonLight", 0.0, 1.0).name("light");
        guiTone = h;
        
        gui.add(effectController, "polarConversion");

        h = gui.addFolder("Tiling");
        h.add(effectController, "tiling").name("enable");
        h.add(effectController, "cRadialMask", 0.0, 1.0).name("radial mask");
        guiTiling = h;
        
        h = gui.addFolder("NormalMap");
        h.add(effectController, "normalMap").name("Generate");
        h.add(effectController, "cHeightScale", 0.0, 10.0);
        guiNormalMap = h;
        
        h = gui.addFolder("ColorBalance");
        h.add(effectController, "cColorBalanceShadowsR", -1.0, 1.0, 0.025).name("Shadows-R");
        h.add(effectController, "cColorBalanceShadowsG", -1.0, 1.0, 0.025).name("Shadows-G");
        h.add(effectController, "cColorBalanceShadowsB", -1.0, 1.0, 0.025).name("Shadows-B");
        h.add(effectController, "cColorBalanceMidtonesR", -1.0, 1.0, 0.025).name("Midtones-R");
        h.add(effectController, "cColorBalanceMidtonesG", -1.0, 1.0, 0.025).name("Midtones-G");
        h.add(effectController, "cColorBalanceMidtonesB", -1.0, 1.0, 0.025).name("Midtones-B");
        h.add(effectController, "cColorBalanceHighlightsR", -1.0, 1.0, 0.025).name("Highlights-R");
        h.add(effectController, "cColorBalanceHighlightsG", -1.0, 1.0, 0.025).name("Highlights-G");
        h.add(effectController, "cColorBalanceHighlightsB", -1.0, 1.0, 0.025).name("Highlights-B");
        h.add(effectController, 'resetColorBalance');
        // h.add(effectController, "colorBlanacePreserveLuminosity");
        guiCB = h;
        
        gui.add(effectController, 'saveImage');
        
        h = gui.addFolder("SpriteSheet");
        h.add(spriteSheet, "dimension", 2, 32).step(1);
        h.add(spriteSheet, "time", 0.0, 1000.0);
        h.add(spriteSheet, "timeLength", 0.1, 1000.0);
        h.add(spriteSheet, "timeStep", 0.0001, 100.0);
        h.add(effectController, 'saveSpriteSheet');
      }
      
      function resetParameters(uniforms) {
        
        for (var i in guiParsItems) {
          guiPars.remove(guiParsItems[i]);
        }
        guiParsItems = [];
        
        for (var key in uniforms) {
          if (key === "resolution" || key === "mouse" || key === "time" || key === "cameraPos" || key === "cameraDir" || key === "tDiffuse" || key.indexOf("toon") === 0 || key.indexOf("Enable") >= 0 ) continue;
          if (key in effectController) {
            effectController[key] = uniforms[key].value;
          }
        }
        
        //MARK: items
        var items = {
          cFrequency: { minValue: 0.0, maxValue: 50.0, name: "Frequency" },
          cPowerExponent: { minValue: 0.0, maxValue:5.0, name: "PowerExponent" },
          cAmplitude: { minValue: 0.0, maxValue: 0.2, name: "Amplitude" },
          cIntensity: { minValue: 0.0, maxValue: 1.0, name: "Intensity", step: 0.01 },
          cDirectionX: { minValue: -1.0, maxValue: 1.0, name: "Direction X", step: 0.1 },
          cDirectionY: { minValue: -1.0, maxValue: 1.0, name: "Direction Y", step: 0.1 },
          cRadius: { minValue: 0.0, maxValue: 2.0, name: "Radius", step: 0.01 },
          cInnerRadius: { minValue: 0.0, maxValue: 2.0, name: "InnerRadius" },
          cInnerRadius2: { minValue: 0.0, maxValue: 2.0, name: "InnerRadius2" },
          cWidth: { minValue: 0.0, maxValue: 1.0, name: "Width", step: 0.01 },
          cHeight: { minValue: 0.0, maxValue: 1.0, name: "Height" },
          cDepth: { minValue: 0.0, maxValue: 1.0, name: "Depth" },
          cOffset: { minValue: 0.0, maxValue: 1.0, name: "Offset", step: 0.1 },
          cPetals: { minValue: 1, maxValue: 20, name: "Petals" },
          cVolume: { minValue: 1, maxValue: 10, name: "Volume" },
          cBeta: { minValue: 1, maxValue: 10, name: "Beta" },
          cDelta: { minValue: 0.01, maxValue: 0.2, name: "Delta" },
          cScale: { minValue: 0.1, maxValue: 1.0, name: "Scale" },
          cSize: { minValue: 0.1, maxValue: 5.0, name: "Size" },
          cColor: { minValue: 0.0, maxValue: 1.0, name: "Color", step: 0.1 },
          cInnerWidth: { minValue: 0.0, maxValue: 1.0, name: "Inner Width" },
          cStrength: { minValue: 0.0, maxValue: 5.0, name: "Strength" },
          cPower: { minValue: 0.0, maxValue: 1.0, name: "Power" },
          cRange: { minValue: 0.0, maxValue: 5.0, name: "Range" },
          cEmission: { minValue: 0.0, maxValue: 1.0, name: "Emission" },
          cBloom: { minValue: 0.0, maxValue: 1.0, name: "Bloom", step: 0.1 },
          cLightX: { minValue: -1.0, maxValue: 1.0, name: "Light X", step: 0.01 },
          cLightY: { minValue: -1.0, maxValue: 1.0, name: "Light Y", step: 0.01 },
          cLightZ: { minValue: -1.0, maxValue: 1.0, name: "Light Z", step: 0.01 },
          cAmbient: { minValue: 0.0, maxValue: 1.0, name: "Ambient" },
          cSmoothness: { minValue: 0.0, maxValue: 1.0, name: "Smoothness" },
          cSmoothnessPower: { minValue: 1.0, maxValue: 5.0, name: "Smoothness Power" },
          cThickness: { minValue: 0.0, maxValue: 1.0, name: "Thickness" },
          cThicknessPower: { minValue: 1.0, maxValue: 5.0, name: "Thickness Power" },
          cCameraTilt: { minValue: 0.0, maxValue: 1.0, name: "CameraTilt", step: 0.01 },
          cCameraPan: { minValue: 0.0, maxValue: 1.0, name: "CameraPan", step: 0.01 },
          cSpeed: { minValue: 0.0, maxValue: 10.0, name: "Speed" },
          cAngle: { minValue: 0.0, maxValue: 360.0, name: "Angle", step: 0.01 },
          cDensity: { minValue: 0.0, maxValue: 1.0, name: "Density", step: 0.01 },
          cAlpha: { minValue: 0.0, maxValue: 1.0, name: "Alpha", step: 0.01 },
          
          cDiamondGearTeeth: { minValue: 8.0, maxValue: 32.0, name: "Teeth", step: 1.0 },
          cDiamondGearMid: { minValue: 0.0, maxValue: 1.0, name: "Mid", step: 0.01 },
          
          cBrushStrokeX1: { minValue: -1.0, maxValue: 1.0, name: "X1", step: 0.01 },
          cBrushStrokeY1: { minValue: -1.0, maxValue: 1.0, name: "Y1", step: 0.01 },
          cBrushStrokeX2: { minValue: -1.0, maxValue: 1.0, name: "X2", step: 0.01 },
          cBrushStrokeY2: { minValue: -1.0, maxValue: 1.0, name: "Y2", step: 0.01 },
          
          cBubblesVariation: { minValue: 1.0, maxValue: 2.0, name: "Variation", step: 1.0 },
          
          cFlameEyeInnerFade: { minValue: 0.01, maxValue: 1.0, name: "InnerFade", step: 0.01 },
          cFlameEyeOuterFade: { minValue: 0.01, maxValue: 1.0, name: "OuterFade", step: 0.01 },
          cFlameEyeBorder: { minValue: 0.01, maxValue: 1.0, name: "Border", step: 0.01 },
          
          cSplatLines: { minValue: 1, maxValue: 100, name: "Lines" },
          cSplatSpotStep: { minValue: 0.02, maxValue: 0.1, name: "Spot Step", step: 0.02 },

          cTrabeculumVariation: { minValue: 0, maxValue: 2, name: "Variation", step: 1 },

          cLifeTime: { minValue: 0.0, maxValue: 1.0, name: "Life Time", step: 0.01 },
          cGravity: { minValue: 0.0, maxValue: 1.0, name: "Gravity", step: 0.01 },
          cCount: { minValue: 0.0, maxValue: 500.0, name: "Count", step: 1.0 },
          
          cExplosionRadius: { minValue: 1.0, maxValue: 2.0, name: "Radius" },
          cExplosionDownScale: { minValue: 1.0, maxValue: 2.0, name: "DownScale" },
          cExplosionGrain: { minValue: 1.0, maxValue: 5.0, name: "Grain" },
          cExplosionSpeed: { minValue: 0.1, maxValue: 2.0, name: "Speed" },
          cExplosionBallness: { minValue: 2.0, maxValue: 50.0, name: "Ballness" },
          cExplosionGrowth: { minValue: 0.1, maxValue: 3.0, name: "Growth" },
          cExplosionFade: { minValue: 1.0, maxValue: 5.0, name: "Fade" },
          cExplosionDensity: { minValue: 0.1, maxValue: 4.0, name: "Density" },
          cExplosionContrast: { minValue: 0.1, maxValue: 4.0, name: "Contrast" },
          cExplosionRollingInitDamp: { minValue: 0.1, maxValue: 2.0, name: "RollingInitDamp" },
          cExplosionRollingSpeed: { minValue: 0.0, maxValue: 4.0, name: "RollingSpeed" },
          cExplosionDelayRange: { minValue: 0.1, maxValue: 2.0, name: "DelayRange" },
          cExplosionBallSpread: { minValue: 0.1, maxValue: 5.0, name: "BallSpread" },
          
          cNoiseOctave: { minValue: 1, maxValue: 8, name: "NoiseOctave" },
          cNoiseFrequency: { minValue: 0.0, maxValue: 2.0, name: "NoiseFrequency", step: 0.01 },
          cNoisePersistence: { minValue: 0.0, maxValue: 1.0, name: "NoisePersistence" },
          cNoiseAmplitude: { minValue: 0.0, maxValue: 1.0, name: "NoiseAmplitude", step: 0.01 },
          cNoiseScale: { minValue: 0.0, maxValue: 1.0, name: "NoiseScale" },
          cNoiseSphereEnable: { name: "NoiseSphere" },
          cNoiseGraphEnable: { name: "NoiseGraph" },
          cNoiseSize: { minValue: 0.1, maxValue: 10.0, name: "NoiseSize" },
          cNoiseStrength: { minValue: 0.1, maxValue: 1.0, name: "NoiseStrength" },
          cNoiseDepth: { minValue: 1, maxValue: 5, name: "NoiseDepth" }
        };
        
        //MARK: override items
        var overrideItems = {
          Circle: {
            cPowerExponent: { minValue: 0.0, maxValue: 50.0 }
          },
          Gradation: {
            cPowerExponent: { minValue: 0.0, maxValue: 50.0 }
          },
          GradationLine: {
            cPowerExponent: { minValue: 0.0, maxValue: 50.0 }
          },
          Cone: {
            cPowerExponent: { minValue: 0.0, maxValue: 50.0 }
          },
          Cell: {
            cPowerExponent: { minValue: 0.0, maxValue: 50.0 }
          },
          Flame: {
            cWidth: { minValue: 0.1, maxValue: 2.0 }
          },
          Lightning: {
            cFrequency: { minValue: 0.0, maxValue: 2.0 },
            cWidth: { minValue: 1.0, maxValue: 10.0 }
          },
          Cloud: {
            cCameraPan: { minValue: 0.0, maxValue: 1.0, defaultValue: 0.0 },
            cCameraTilt: { minValue: 0.0, maxValue: 1.0, defaultValue: 0.0 }
          },
          Checker: {
            cWidth: { minValue: 1.0, maxValue: 100.0 },
            cHeight: { minValue: 1.0, maxValue: 100.0 }
          },
          FbmNoise2: {
            cNoiseOctave: { minValue: 1.0, maxValue: 3.0, defaultValue: 3.0 },
            cNoiseAmplitude: { minValue: 0.0, maxValue: 0.5, defaultValue: 0.25 },
            cNoiseFrequency: { minValue: 0.0, maxValue: 1.0, defaultValue: 1.0 }
          },
          FbmNoise3: {
            cNoiseOctave: { minValue: 1.0, maxValue: 8.0, defaultValue: 5.0 },
            cNoiseAmplitude: { minValue: 0.5, maxValue: 1.5, defaultValue: 1.0 },
            cNoiseFrequency: { minValue: 0.0, maxValue: 2.0, defaultValue: 0.5 },
            cNoiseScale: { minValue: 0.01, maxValue: 1.0 }
          },
          MarbleNoise: {
            cScale: { minValue: 1.0, maxValue: 100.0 },
            cFrequency: { minValue: 1.0, maxValue: 100.0 }
          },
          TessNoise: {
            cNoiseFrequency: { minValue: 0.0, maxValue: 1.0, defaultValue: 0.1 }
          },
          FlameEye: {
            cSpeed: { minValue: 0.1, maxValue: 1.0 }
          },
          FlameLance: {
            cSize: { minValue: 1.0, maxValue: 100.0 },
            cSpeed: { minValue: 0.1, maxValue: 5.0 },
            cPower: { minValue: 0.1, maxValue: 10.0 },
            cAngle: { minValue: -1.0, maxValue: 1.0 }
          },
          Bonfire: {
            cSpeed: { minValue: 0.1, maxValue: 1.0 },
            cIntensity: { minValue: 0.1, maxValue: 5.0 },
            cStrength: { minValue: 0.1, maxValue: 1.0 },
            cDensity: { minValue: 0.1, maxValue: 4.0 },
            cSize: { minValue: 0.0, maxValue: 10.0 }
          },
          Snow: {
            cDensity: { minValue: 0.1, maxValue: 6.0 },
            cRange: { minValue: 0.1, maxValue: 1.0 }
          },
          DiamondGear: {
            cWidth: { minValue: 0.1, maxValue: 8.0 }
          },
          BrushStroke: {
            cWidth: { minValue: 0.0, maxValue: 1.0, defaultValue: 0.3 },
            cAlpha: { minValue: 0.0, maxValue: 1.0, defaultValue: 0.58 },
            cStrength: { minValue: 0.1, maxValue: 1.0, defaultValue: 0.6 },
            cAngle: { minValue: 0.0, maxValue: 1.0 },
            cAmplitude: { minValue: 0.0, maxValue: 1.0 }
          },
          Speckle: {
            cRadius: { minValue: 0.01, maxValue: 1.0, defaultValue: 1.0 },
            cDensity: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.1 },
            cScale: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.01 }
          },
          Pentagon: {
            cWidth: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.02 },
            cScale: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.5 },
            cAlpha: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.38 }
          },
          Grunge: {
            cRadius: { minValue: 0.01, maxValue: 1.0 }
          },
          Energy: {
            cPower: { minValue: 0.0, maxValue: 1.0 },
            cFrequency: { minValue: 0.0, maxValue: 1.0 }
          },
          Particle: {
            cSize: { minValue: 0.01, maxValue: 0.5 }
          },
          Electric: {
            cFrequency: { minValue: 10.0, maxValue: 50.0 },
            cScale: { minValue: 0.01, maxValue: 1.0 }
          },
          Caustics: {
            cScale: { minValue: 1.0, maxValue: 10.0 },
            cSpeed: { minValue: 1.0, maxValue: 4.0 }
          },
          Squiggles: {
            cSize: { minValue: 1.0, maxValue: 8.0 },
            cScale: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.5 },
            cDensity: { minValue: 1.0, maxValue: 16.0 }
          },
          WaterTurbulence: {
            cSize: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.4 },
            cIntensity: { minValue: 0.01, maxValue: 1.0, defaultValue: 0.15 }
          },
          Trabeculum: {
            cDensity: { minValue: 0.0, maxValue: 1.0, defaultValue: 1.0 },
            cScale: { minValue: 0.01, maxValue: 1.0, defaultValue: 1.0 },
            cCameraPan: { minValue: 0.0, maxValue: 1.0, defaultValue: 0.5 },
            cCameraTilt: { minValue: 0.0, maxValue: 1.0, defaultValue: 0.5 }
          }
        };
        
        //MARK: parsTable
        var parsTable = {
          Wood:   ["cFrequency", "cPowerExponent"],
          Circle: ["cRadius", "cPowerExponent"],
          Solar:  ["cIntensity", "cPowerExponent"],
          Spark:  ["cIntensity", "cPowerExponent"],
          Ring:   ["cRadius", "cWidth", "cPowerExponent"],
          Gradation: ["cDirectionX", "cDirectionY", "cPowerExponent"],
          GradationLine: ["cDirectionX", "cDirectionY", "cOffset", "cPowerExponent"],
          Flash:  ["cFrequency", "cPowerExponent"],
          Cone:   ["cDirectionX", "cDirectionY", "cPowerExponent"],
          Flower: ["cPetals", "cRadius", "cIntensity", "cPowerExponent"],
          FlowerFun: ["cPetals", "cRadius", "cOffset", "cIntensity", "cPowerExponent"],
          WaveRing: ["cRadius", "cWidth", "cFrequency", "cAmplitude", "cPowerExponent"],
          Flame:  ["cIntensity", "cWidth", "cScale" ],
          FlameEye: ["cSpeed", "cFlameEyeInnerFade", "cFlameEyeOuterFade", "cFlameEyeBorder", "cColor"],
          Cell:   ["cIntensity", "cPowerExponent", "cSize" ],
          Smoke:  ["cVolume", "cBeta", "cDelta"],
          Lightning: ["cIntensity", "cFrequency", "cWidth"],
          Flare:  ["cIntensity", "cPowerExponent"],
          Flare2: ["cIntensity", "cPowerExponent"],
          Flare3: ["cIntensity", "cPowerExponent"],
          MagicCircle: [],
          Mandara: ["cRadius", "cInnerRadius", "cInnerRadius2"],
          Cross:  ["cIntensity", "cPowerExponent"],
          Explosion: [
            "cCameraTilt", "cCameraPan",
            "cExplosionRadius", "cExplosionDownScale", "cExplosionGrain", "cExplosionSpeed",
            "cExplosionBallness", "cExplosionGrowth", "cExplosionFade", "cExplosionDensity",
            "cExplosionContrast", "cExplosionRollingInitDamp", "cExplosionRollingSpeed",
            "cExplosionDelayRange", "cExplosionBallSpread"],
          Explosion2: [
            "cCameraPan", 
            "cExplosionSpeed", "cExplosionDensity",
            "cEmission", "cBloom", "cColor"],
          Corona: ["cIntensity", "cRadius", "cSize"],
          Fire: ["cIntensity", "cStrength", "cPower", "cRange", "cWidth", "cColor"],
          LensFlare: ["cRadius", "cRange", "cColor", "cPowerExponent"],
          Sun:  ["cRadius", "cColor"],
          Laser: ["cWidth", "cColor"],
          Laser2: ["cWidth", "cInnerWidth"],
          Light: ["cRadius", "cPowerExponent", "cColor"],
          Cloud: [
            "cWidth", "cHeight", "cDepth", 
            "cIntensity", "cLightX", "cLightY", "cLightZ", "cAmbient",
            "cSmoothness", "cSmoothnessPower", "cThickness", "cThicknessPower", 
            "cCameraTilt", "cCameraPan"],
          Cloud2: ["cIntensity", "cDensity", "cThickness", "cColor"],
          
          PerlinNoise: ["cNoiseOctave", "cNoisePersistence", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          SeemlessNoise: ["cNoiseOctave", "cNoisePersistence", "cNoiseScale", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          BooleanNoise: ["cNoiseFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          CellNoise: ["cNoiseFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          RandomNoise: ["cNoiseFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          FbmNoise: ["cNoiseOctave", "cNoiseAmplitude", "cNoiseFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          FbmNoise2: ["cNoiseOctave", "cNoiseAmplitude", "cNoiseFrequency", "cScale", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          FbmNoise3: ["cNoiseOctave", "cNoiseAmplitude", "cNoiseFrequency", "cNoiseScale", "cOffset", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          TurbulentNoise: ["cNoiseOctave", "cNoiseAmplitude", "cNoiseFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          SparkNoise: ["cNoiseFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          VoronoiNoise: ["cNoiseFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          MarbleNoise: ["cScale", "cFrequency", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          TessNoise: [ "cNoiseFrequency", "cOffset",  "cNoiseSphereEnable", "cNoiseGraphEnable"],
          GradientNoise: [ "cNoiseScale", "cColor", "cNoiseSphereEnable", "cNoiseGraphEnable"],
          
          Checker: ["cWidth", "cHeight"],
          FlameLance: ["cSize", "cSpeed", "cPower", "cAngle", "cColor",  "cNoiseSize", "cNoiseStrength", "cNoiseDepth"],
          Bonfire: ["cSpeed", "cIntensity", "cStrength", "cDensity", "cSize", "cColor"],
          Snow: ["cSpeed", "cScale", "cDensity", "cRange"],
          DiamondGear: ["cScale", "cWidth", "cRadius", "cDiamondGearTeeth", "cDiamondGearMid"],
          BrushStroke: ["cWidth", "cStrength", "cAlpha", "cAngle", "cAmplitude", "cBrushStrokeX1", "cBrushStrokeY1", "cBrushStrokeX2", "cBrushStrokeY2", "cColor"],
          Speckle: ["cRadius", "cScale", "cDensity"],
          Bubbles: ["cRadius", "cWidth", "cThickness", "cColor", "cBubblesVariation"],
          Pentagon: ["cScale", "cAlpha", "cWidth"],
          Grunge: ["cRadius", "cScale"],
          Energy: ["cPower", "cDensity", "cThickness", "cScale", "cFrequency", "cColor"],
          InkSplat: ["cSplatLines", "cSplatSpotStep"],
          Particle: ["cSize", "cLifeTime", "cGravity", "cCount"],
          Electric: ["cFrequency", "cScale"],
          Caustics: ["cScale", "cSpeed", "cColor"],
          Squiggles: ["cSize", "cScale", "cDensity"],
          WaterTurbulence: ["cScale", "cIntensity"],
          Trabeculum: ["cDensity", "cScale", "cIntensity", "cTrabeculumVariation", "cCameraTilt", "cCameraPan", "cColor"],
          //MARK: add new pars here
          
          Test: [],
        };
        
        var pars = parsTable[effectController.type];
        for (var i=0; i<pars.length; i++) {
          var item = items[ pars[i] ];
          if (pars[i].indexOf("Enable") >= 0) {
            guiParsItems.push(guiPars.add(effectController, pars[i]).name(item.name));
          }
          else {
            var override = false;
            if (effectController.type in overrideItems) {
              if (pars[i] in overrideItems[effectController.type]) {
                override = true;
              }
            }
            
            if (override) {
              var overrideItem = overrideItems[effectController.type][ pars[i] ];
              if ("defaultValue" in overrideItem) {
                effectController[ pars[i] ] = overrideItem.defaultValue;
              }
              var guiItem = guiPars.add(effectController, pars[i], overrideItem.minValue, overrideItem.maxValue).name(item.name);
              if ("step" in item) {
                guiItem.step(item.step);
              }
              if ("step" in overrideItem) {
                guiItem.step(override.step);
              }
              guiParsItems.push(guiItem);
            }
            else {
              var guiItem = guiPars.add(effectController, pars[i], item.minValue, item.maxValue).name(item.name);
              if ("step" in item) {
                guiItem.step(item.step);
              }
              guiParsItems.push(guiItem);
            }
          }
        }
      }
      
      function animate() {
        if (effectController.animate) {
          effectController.time += clock.getDelta();
          // console.log(effectController.time);
        }
        
        var time = effectController.time;
        var str = time.toString() + "0000000";
        if (time === 0) str = "0.00000000";
        document.getElementById("time").innerHTML = str.substr(0, 8);
        
        requestAnimationFrame(animate, renderer.domElement);
        render();
      }
      
      function render() {
        
        stats.update();
        
        for (var i=0; i<layers.length; i++) {
          
          var layer = layers[i];
          var target = layer.renderTarget;
          var texture = layer.tDiffuse;
          
          if (layer.name === "NormalMap" && effectController.normalMap === false) {
            layer = layers[layers.length-1];
          }
          if (layer.name === "PolarConversion" && effectController.polarConversion === false) {
            layer = layers[layers.length-1];
          }
          if (layer.name === "Tiling" && effectController.tiling === false) {
            layer = layers[layers.length-1];
          }
          
          layer.uniforms.resolution.value = new THREE.Vector2(canvas.width, canvas.height);
          camera.getWorldPosition(layer.uniforms.cameraPos.value);
          camera.getWorldDirection(layer.uniforms.cameraDir.value);
          layer.uniforms.mouse.value.copy(mouse);
          // layer.uniforms.time.value = effectController.time;
          layer.uniforms.tDiffuse.value = texture;
          
          for (key in effectController) {
            if (key === "resolution") continue;
            PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, key, effectController[key]);
          }
          
          // PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, "heightScale", effectController.heightScale);
          PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, "cColorBalanceShadows", 
            new THREE.Vector3(
              effectController.cColorBalanceShadowsR,
              effectController.cColorBalanceShadowsG,
              effectController.cColorBalanceShadowsB));
          PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, "cColorBalanceMidtones", 
            new THREE.Vector3(
              effectController.cColorBalanceMidtonesR,
              effectController.cColorBalanceMidtonesG,
              effectController.cColorBalanceMidtonesB));
          PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, "cColorBalanceHighlights", 
            new THREE.Vector3(
              effectController.cColorBalanceHighlightsR,
              effectController.cColorBalanceHighlightsG,
              effectController.cColorBalanceHighlightsB));
          PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, "cDirection",
            new THREE.Vector2(
              effectController.cDirectionX,
              effectController.cDirectionY));
          // PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, "tNoise", noiseTexture);
          PIXY.FxgenShaderUtils.SetShaderParameter(layer.uniforms, "tGrunge", grungeTexture);
        
          scene.overrideMaterial = layer.material;
          renderer.setRenderTarget(target);
          renderer.render(scene, dummyCamera);
          renderer.setRenderTarget(null);
          scene.overrideMaterial = null;
        }
        
        if (effectController.cNoiseSphereEnable) {
          noiseUniforms.tDisplacement.value = layers[layers.length-2].renderTarget.texture;
          renderer.render(noiseScene, camera);
        }
      }

    </script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-5766141-1', 'auto');
  ga('send', 'pageview');

  </script>
  </body>
</html>
